// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "protocol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace OstProto {

namespace {

const ::google::protobuf::Descriptor* VersionInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VersionInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* VersionCompatibility_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VersionCompatibility_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* VersionCompatibility_Compatibility_descriptor_ = NULL;
const ::google::protobuf::Descriptor* StreamId_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StreamId_reflection_ = NULL;
const ::google::protobuf::Descriptor* StreamCore_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StreamCore_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* StreamCore_FrameLengthMode_descriptor_ = NULL;
const ::google::protobuf::Descriptor* StreamControl_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StreamControl_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* StreamControl_SendUnit_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* StreamControl_SendMode_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* StreamControl_NextWhat_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ProtocolId_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProtocolId_reflection_ = NULL;
const ::google::protobuf::Descriptor* Protocol_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Protocol_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Protocol_k_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Stream_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Stream_reflection_ = NULL;
const ::google::protobuf::Descriptor* Void_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Void_reflection_ = NULL;
const ::google::protobuf::Descriptor* Ack_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Ack_reflection_ = NULL;
const ::google::protobuf::Descriptor* PortId_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PortId_reflection_ = NULL;
const ::google::protobuf::Descriptor* PortIdList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PortIdList_reflection_ = NULL;
const ::google::protobuf::Descriptor* StreamIdList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StreamIdList_reflection_ = NULL;
const ::google::protobuf::Descriptor* Port_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Port_reflection_ = NULL;
const ::google::protobuf::Descriptor* PortConfigList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PortConfigList_reflection_ = NULL;
const ::google::protobuf::Descriptor* StreamConfigList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StreamConfigList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CaptureBuffer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CaptureBuffer_reflection_ = NULL;
const ::google::protobuf::Descriptor* CaptureBufferList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CaptureBufferList_reflection_ = NULL;
const ::google::protobuf::Descriptor* PortState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PortState_reflection_ = NULL;
const ::google::protobuf::Descriptor* PortStats_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PortStats_reflection_ = NULL;
const ::google::protobuf::Descriptor* PortStatsList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PortStatsList_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TransmitMode_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* LinkState_descriptor_ = NULL;
const ::google::protobuf::ServiceDescriptor* OstService_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_protocol_2eproto() {
  protobuf_AddDesc_protocol_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "protocol.proto");
  GOOGLE_CHECK(file != NULL);
  VersionInfo_descriptor_ = file->message_type(0);
  static const int VersionInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, version_),
  };
  VersionInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VersionInfo_descriptor_,
      VersionInfo::default_instance_,
      VersionInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VersionInfo));
  VersionCompatibility_descriptor_ = file->message_type(1);
  static const int VersionCompatibility_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionCompatibility, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionCompatibility, notes_),
  };
  VersionCompatibility_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VersionCompatibility_descriptor_,
      VersionCompatibility::default_instance_,
      VersionCompatibility_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionCompatibility, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionCompatibility, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VersionCompatibility));
  VersionCompatibility_Compatibility_descriptor_ = VersionCompatibility_descriptor_->enum_type(0);
  StreamId_descriptor_ = file->message_type(2);
  static const int StreamId_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamId, id_),
  };
  StreamId_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StreamId_descriptor_,
      StreamId::default_instance_,
      StreamId_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamId, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamId, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StreamId));
  StreamCore_descriptor_ = file->message_type(3);
  static const int StreamCore_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamCore, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamCore, is_enabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamCore, ordinal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamCore, len_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamCore, frame_len_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamCore, frame_len_min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamCore, frame_len_max_),
  };
  StreamCore_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StreamCore_descriptor_,
      StreamCore::default_instance_,
      StreamCore_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamCore, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamCore, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StreamCore));
  StreamCore_FrameLengthMode_descriptor_ = StreamCore_descriptor_->enum_type(0);
  StreamControl_descriptor_ = file->message_type(4);
  static const int StreamControl_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, unit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, num_packets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, num_bursts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, packets_per_burst_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, next_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, obsolete_packets_per_sec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, obsolete_bursts_per_sec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, packets_per_sec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, bursts_per_sec_),
  };
  StreamControl_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StreamControl_descriptor_,
      StreamControl::default_instance_,
      StreamControl_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamControl, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StreamControl));
  StreamControl_SendUnit_descriptor_ = StreamControl_descriptor_->enum_type(0);
  StreamControl_SendMode_descriptor_ = StreamControl_descriptor_->enum_type(1);
  StreamControl_NextWhat_descriptor_ = StreamControl_descriptor_->enum_type(2);
  ProtocolId_descriptor_ = file->message_type(5);
  static const int ProtocolId_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtocolId, id_),
  };
  ProtocolId_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProtocolId_descriptor_,
      ProtocolId::default_instance_,
      ProtocolId_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtocolId, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtocolId, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProtocolId));
  Protocol_descriptor_ = file->message_type(6);
  static const int Protocol_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Protocol, protocol_id_),
  };
  Protocol_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Protocol_descriptor_,
      Protocol::default_instance_,
      Protocol_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Protocol, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Protocol, _unknown_fields_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Protocol, _extensions_),
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Protocol));
  Protocol_k_descriptor_ = Protocol_descriptor_->enum_type(0);
  Stream_descriptor_ = file->message_type(7);
  static const int Stream_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream, stream_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream, core_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream, control_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream, protocol_),
  };
  Stream_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Stream_descriptor_,
      Stream::default_instance_,
      Stream_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Stream));
  Void_descriptor_ = file->message_type(8);
  static const int Void_offsets_[1] = {
  };
  Void_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Void_descriptor_,
      Void::default_instance_,
      Void_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Void, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Void, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Void));
  Ack_descriptor_ = file->message_type(9);
  static const int Ack_offsets_[1] = {
  };
  Ack_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Ack_descriptor_,
      Ack::default_instance_,
      Ack_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ack, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ack, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Ack));
  PortId_descriptor_ = file->message_type(10);
  static const int PortId_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortId, id_),
  };
  PortId_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PortId_descriptor_,
      PortId::default_instance_,
      PortId_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortId, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortId, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PortId));
  PortIdList_descriptor_ = file->message_type(11);
  static const int PortIdList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortIdList, port_id_),
  };
  PortIdList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PortIdList_descriptor_,
      PortIdList::default_instance_,
      PortIdList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortIdList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortIdList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PortIdList));
  StreamIdList_descriptor_ = file->message_type(12);
  static const int StreamIdList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamIdList, port_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamIdList, stream_id_),
  };
  StreamIdList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StreamIdList_descriptor_,
      StreamIdList::default_instance_,
      StreamIdList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamIdList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamIdList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StreamIdList));
  Port_descriptor_ = file->message_type(13);
  static const int Port_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, port_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, notes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, is_enabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, is_exclusive_control_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, transmit_mode_),
  };
  Port_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Port_descriptor_,
      Port::default_instance_,
      Port_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Port));
  PortConfigList_descriptor_ = file->message_type(14);
  static const int PortConfigList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortConfigList, port_),
  };
  PortConfigList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PortConfigList_descriptor_,
      PortConfigList::default_instance_,
      PortConfigList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortConfigList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortConfigList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PortConfigList));
  StreamConfigList_descriptor_ = file->message_type(15);
  static const int StreamConfigList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamConfigList, port_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamConfigList, stream_),
  };
  StreamConfigList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StreamConfigList_descriptor_,
      StreamConfigList::default_instance_,
      StreamConfigList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamConfigList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamConfigList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StreamConfigList));
  CaptureBuffer_descriptor_ = file->message_type(16);
  static const int CaptureBuffer_offsets_[1] = {
  };
  CaptureBuffer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CaptureBuffer_descriptor_,
      CaptureBuffer::default_instance_,
      CaptureBuffer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaptureBuffer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaptureBuffer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CaptureBuffer));
  CaptureBufferList_descriptor_ = file->message_type(17);
  static const int CaptureBufferList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaptureBufferList, list_),
  };
  CaptureBufferList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CaptureBufferList_descriptor_,
      CaptureBufferList::default_instance_,
      CaptureBufferList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaptureBufferList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaptureBufferList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CaptureBufferList));
  PortState_descriptor_ = file->message_type(18);
  static const int PortState_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortState, link_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortState, is_transmit_on_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortState, is_capture_on_),
  };
  PortState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PortState_descriptor_,
      PortState::default_instance_,
      PortState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PortState));
  PortStats_descriptor_ = file->message_type(19);
  static const int PortStats_offsets_[18] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, port_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, rx_pkts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, rx_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, rx_pkts_nic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, rx_bytes_nic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, rx_pps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, rx_bps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, tx_pkts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, tx_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, tx_pkts_nic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, tx_bytes_nic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, tx_pps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, tx_bps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, rx_drops_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, rx_errors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, rx_fifo_errors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, rx_frame_errors_),
  };
  PortStats_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PortStats_descriptor_,
      PortStats::default_instance_,
      PortStats_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStats, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PortStats));
  PortStatsList_descriptor_ = file->message_type(20);
  static const int PortStatsList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStatsList, port_stats_),
  };
  PortStatsList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PortStatsList_descriptor_,
      PortStatsList::default_instance_,
      PortStatsList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStatsList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PortStatsList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PortStatsList));
  TransmitMode_descriptor_ = file->enum_type(0);
  LinkState_descriptor_ = file->enum_type(1);
  OstService_descriptor_ = file->service(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_protocol_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VersionInfo_descriptor_, &VersionInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VersionCompatibility_descriptor_, &VersionCompatibility::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StreamId_descriptor_, &StreamId::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StreamCore_descriptor_, &StreamCore::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StreamControl_descriptor_, &StreamControl::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProtocolId_descriptor_, &ProtocolId::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Protocol_descriptor_, &Protocol::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Stream_descriptor_, &Stream::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Void_descriptor_, &Void::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Ack_descriptor_, &Ack::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PortId_descriptor_, &PortId::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PortIdList_descriptor_, &PortIdList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StreamIdList_descriptor_, &StreamIdList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Port_descriptor_, &Port::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PortConfigList_descriptor_, &PortConfigList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StreamConfigList_descriptor_, &StreamConfigList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CaptureBuffer_descriptor_, &CaptureBuffer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CaptureBufferList_descriptor_, &CaptureBufferList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PortState_descriptor_, &PortState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PortStats_descriptor_, &PortStats::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PortStatsList_descriptor_, &PortStatsList::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_protocol_2eproto() {
  delete VersionInfo::default_instance_;
  delete VersionInfo_reflection_;
  delete VersionCompatibility::default_instance_;
  delete VersionCompatibility_reflection_;
  delete StreamId::default_instance_;
  delete StreamId_reflection_;
  delete StreamCore::default_instance_;
  delete StreamCore_reflection_;
  delete StreamControl::default_instance_;
  delete StreamControl_reflection_;
  delete ProtocolId::default_instance_;
  delete ProtocolId_reflection_;
  delete Protocol::default_instance_;
  delete Protocol_reflection_;
  delete Stream::default_instance_;
  delete Stream_reflection_;
  delete Void::default_instance_;
  delete Void_reflection_;
  delete Ack::default_instance_;
  delete Ack_reflection_;
  delete PortId::default_instance_;
  delete PortId_reflection_;
  delete PortIdList::default_instance_;
  delete PortIdList_reflection_;
  delete StreamIdList::default_instance_;
  delete StreamIdList_reflection_;
  delete Port::default_instance_;
  delete Port_reflection_;
  delete PortConfigList::default_instance_;
  delete PortConfigList_reflection_;
  delete StreamConfigList::default_instance_;
  delete StreamConfigList_reflection_;
  delete CaptureBuffer::default_instance_;
  delete CaptureBuffer_reflection_;
  delete CaptureBufferList::default_instance_;
  delete CaptureBufferList_reflection_;
  delete PortState::default_instance_;
  delete PortState_reflection_;
  delete PortStats::default_instance_;
  delete PortStats_reflection_;
  delete PortStatsList::default_instance_;
  delete PortStatsList_reflection_;
}

void protobuf_AddDesc_protocol_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016protocol.proto\022\010OstProto\"\036\n\013VersionInf"
    "o\022\017\n\007version\030\001 \002(\t\"\230\001\n\024VersionCompatibil"
    "ity\022<\n\006result\030\001 \002(\0162,.OstProto.VersionCo"
    "mpatibility.Compatibility\022\r\n\005notes\030\002 \001(\t"
    "\"3\n\rCompatibility\022\021\n\rkIncompatible\020\000\022\017\n\013"
    "kCompatible\020\001\"\026\n\010StreamId\022\n\n\002id\030\001 \002(\r\"\242\002"
    "\n\nStreamCore\022\014\n\004name\030\001 \001(\t\022\022\n\nis_enabled"
    "\030\002 \001(\010\022\017\n\007ordinal\030\003 \001(\r\022B\n\010len_mode\030\016 \001("
    "\0162$.OstProto.StreamCore.FrameLengthMode:"
    "\ne_fl_fixed\022\025\n\tframe_len\030\017 \001(\r:\00264\022\031\n\rfr"
    "ame_len_min\030\020 \001(\r:\00264\022\033\n\rframe_len_max\030\021"
    " \001(\r:\0041518\"N\n\017FrameLengthMode\022\016\n\ne_fl_fi"
    "xed\020\000\022\014\n\010e_fl_inc\020\001\022\014\n\010e_fl_dec\020\002\022\017\n\013e_f"
    "l_random\020\003\"\300\004\n\rStreamControl\022<\n\004unit\030\001 \001"
    "(\0162 .OstProto.StreamControl.SendUnit:\014e_"
    "su_packets\022:\n\004mode\030\002 \001(\0162 .OstProto.Stre"
    "amControl.SendMode:\ne_sm_fixed\022\026\n\013num_pa"
    "ckets\030\003 \001(\r:\0011\022\025\n\nnum_bursts\030\004 \001(\r:\0011\022\035\n"
    "\021packets_per_burst\030\005 \001(\r:\00210\022>\n\004next\030\006 \001"
    "(\0162 .OstProto.StreamControl.NextWhat:\016e_"
    "nw_goto_next\022\'\n\030OBSOLETE_packets_per_sec"
    "\030\007 \001(\r:\0011B\002\030\001\022&\n\027OBSOLETE_bursts_per_sec"
    "\030\010 \001(\r:\0011B\002\030\001\022\032\n\017packets_per_sec\030\t \001(\001:\001"
    "1\022\031\n\016bursts_per_sec\030\n \001(\001:\0011\"-\n\010SendUnit"
    "\022\020\n\014e_su_packets\020\000\022\017\n\013e_su_bursts\020\001\"/\n\010S"
    "endMode\022\016\n\ne_sm_fixed\020\000\022\023\n\017e_sm_continuo"
    "us\020\001\"\?\n\010NextWhat\022\r\n\te_nw_stop\020\000\022\022\n\016e_nw_"
    "goto_next\020\001\022\020\n\014e_nw_goto_id\020\002\"\030\n\nProtoco"
    "lId\022\n\n\002id\030\001 \002(\r\"\335\005\n\010Protocol\022)\n\013protocol"
    "_id\030\001 \002(\0132\024.OstProto.ProtocolId\"\226\005\n\001k\022\023\n"
    "\017kMacFieldNumber\020d\022\027\n\023kPayloadFieldNumbe"
    "r\020e\022\026\n\022kSampleFieldNumber\020f\022\032\n\026kUserScri"
    "ptFieldNumber\020g\022\027\n\023kHexDumpFieldNumber\020h"
    "\022\025\n\020kEth2FieldNumber\020\310\001\022\025\n\020kDot3FieldNum"
    "ber\020\311\001\022\024\n\017kLlcFieldNumber\020\312\001\022\025\n\020kSnapFie"
    "ldNumber\020\313\001\022\026\n\021kSvlanFieldNumber\020\314\001\022\025\n\020k"
    "VlanFieldNumber\020\315\001\022\030\n\023kDot2LlcFieldNumbe"
    "r\020\316\001\022\031\n\024kDot2SnapFieldNumber\020\317\001\022\032\n\025kVlan"
    "StackFieldNumber\020\320\001\022\024\n\017kArpFieldNumber\020\254"
    "\002\022\024\n\017kIp4FieldNumber\020\255\002\022\024\n\017kIp6FieldNumb"
    "er\020\256\002\022\031\n\024kIp6over4FieldNumber\020\257\002\022\031\n\024kIp4"
    "over6FieldNumber\020\260\002\022\031\n\024kIp4over4FieldNum"
    "ber\020\261\002\022\031\n\024kIp6over6FieldNumber\020\262\002\022\024\n\017kTc"
    "pFieldNumber\020\220\003\022\024\n\017kUdpFieldNumber\020\221\003\022\025\n"
    "\020kIcmpFieldNumber\020\222\003\022\025\n\020kIgmpFieldNumber"
    "\020\223\003\022\024\n\017kMldFieldNumber\020\224\003\022\035\n\030kTextProtoc"
    "olFieldNumber\020\364\003*\005\010d\020\310\001*\006\010\310\001\020\365\003\"\243\001\n\006Stre"
    "am\022%\n\tstream_id\030\001 \002(\0132\022.OstProto.StreamI"
    "d\022\"\n\004core\030\002 \001(\0132\024.OstProto.StreamCore\022(\n"
    "\007control\030\003 \001(\0132\027.OstProto.StreamControl\022"
    "$\n\010protocol\030\004 \003(\0132\022.OstProto.Protocol\"\006\n"
    "\004Void\"\005\n\003Ack\"\024\n\006PortId\022\n\n\002id\030\001 \002(\r\"/\n\nPo"
    "rtIdList\022!\n\007port_id\030\001 \003(\0132\020.OstProto.Por"
    "tId\"X\n\014StreamIdList\022!\n\007port_id\030\001 \002(\0132\020.O"
    "stProto.PortId\022%\n\tstream_id\030\002 \003(\0132\022.OstP"
    "roto.StreamId\"\321\001\n\004Port\022!\n\007port_id\030\001 \002(\0132"
    "\020.OstProto.PortId\022\014\n\004name\030\002 \001(\t\022\023\n\013descr"
    "iption\030\003 \001(\t\022\r\n\005notes\030\004 \001(\t\022\022\n\nis_enable"
    "d\030\005 \001(\010\022\034\n\024is_exclusive_control\030\006 \001(\010\022B\n"
    "\rtransmit_mode\030\007 \001(\0162\026.OstProto.Transmit"
    "Mode:\023kSequentialTransmit\".\n\016PortConfigL"
    "ist\022\034\n\004port\030\001 \003(\0132\016.OstProto.Port\"W\n\020Str"
    "eamConfigList\022!\n\007port_id\030\001 \002(\0132\020.OstProt"
    "o.PortId\022 \n\006stream\030\002 \003(\0132\020.OstProto.Stre"
    "am\"\017\n\rCaptureBuffer\":\n\021CaptureBufferList"
    "\022%\n\004list\030\001 \003(\0132\027.OstProto.CaptureBuffer\""
    "\203\001\n\tPortState\0229\n\nlink_state\030\001 \001(\0162\023.OstP"
    "roto.LinkState:\020LinkStateUnknown\022\035\n\016is_t"
    "ransmit_on\030\002 \001(\010:\005false\022\034\n\ris_capture_on"
    "\030\003 \001(\010:\005false\"\204\003\n\tPortStats\022!\n\007port_id\030\001"
    " \002(\0132\020.OstProto.PortId\022\"\n\005state\030\002 \001(\0132\023."
    "OstProto.PortState\022\017\n\007rx_pkts\030\013 \001(\004\022\020\n\010r"
    "x_bytes\030\014 \001(\004\022\023\n\013rx_pkts_nic\030\r \001(\004\022\024\n\014rx"
    "_bytes_nic\030\016 \001(\004\022\016\n\006rx_pps\030\017 \001(\004\022\016\n\006rx_b"
    "ps\030\020 \001(\004\022\017\n\007tx_pkts\030\025 \001(\004\022\020\n\010tx_bytes\030\026 "
    "\001(\004\022\023\n\013tx_pkts_nic\030\027 \001(\004\022\024\n\014tx_bytes_nic"
    "\030\030 \001(\004\022\016\n\006tx_pps\030\031 \001(\004\022\016\n\006tx_bps\030\032 \001(\004\022\020"
    "\n\010rx_drops\030d \001(\004\022\021\n\trx_errors\030e \001(\004\022\026\n\016r"
    "x_fifo_errors\030f \001(\004\022\027\n\017rx_frame_errors\030g"
    " \001(\004\"8\n\rPortStatsList\022\'\n\nport_stats\030\001 \003("
    "\0132\023.OstProto.PortStats*A\n\014TransmitMode\022\027"
    "\n\023kSequentialTransmit\020\000\022\030\n\024kInterleavedT"
    "ransmit\020\001*E\n\tLinkState\022\024\n\020LinkStateUnkno"
    "wn\020\000\022\021\n\rLinkStateDown\020\001\022\017\n\013LinkStateUp\020\002"
    "2\255\007\n\nOstService\0225\n\rgetPortIdList\022\016.OstPr"
    "oto.Void\032\024.OstProto.PortIdList\022\?\n\rgetPor"
    "tConfig\022\024.OstProto.PortIdList\032\030.OstProto"
    ".PortConfigList\0225\n\nmodifyPort\022\030.OstProto"
    ".PortConfigList\032\r.OstProto.Ack\022;\n\017getStr"
    "eamIdList\022\020.OstProto.PortId\032\026.OstProto.S"
    "treamIdList\022E\n\017getStreamConfig\022\026.OstProt"
    "o.StreamIdList\032\032.OstProto.StreamConfigLi"
    "st\0222\n\taddStream\022\026.OstProto.StreamIdList\032"
    "\r.OstProto.Ack\0225\n\014deleteStream\022\026.OstProt"
    "o.StreamIdList\032\r.OstProto.Ack\0229\n\014modifyS"
    "tream\022\032.OstProto.StreamConfigList\032\r.OstP"
    "roto.Ack\0224\n\rstartTransmit\022\024.OstProto.Por"
    "tIdList\032\r.OstProto.Ack\0223\n\014stopTransmit\022\024"
    ".OstProto.PortIdList\032\r.OstProto.Ack\0223\n\014s"
    "tartCapture\022\024.OstProto.PortIdList\032\r.OstP"
    "roto.Ack\0222\n\013stopCapture\022\024.OstProto.PortI"
    "dList\032\r.OstProto.Ack\022=\n\020getCaptureBuffer"
    "\022\020.OstProto.PortId\032\027.OstProto.CaptureBuf"
    "fer\0229\n\010getStats\022\024.OstProto.PortIdList\032\027."
    "OstProto.PortStatsList\0221\n\nclearStats\022\024.O"
    "stProto.PortIdList\032\r.OstProto.Ack\022E\n\014che"
    "ckVersion\022\025.OstProto.VersionInfo\032\036.OstPr"
    "oto.VersionCompatibilityB\006\200\001\001\220\001\001", 4312);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "protocol.proto", &protobuf_RegisterTypes);
  VersionInfo::default_instance_ = new VersionInfo();
  VersionCompatibility::default_instance_ = new VersionCompatibility();
  StreamId::default_instance_ = new StreamId();
  StreamCore::default_instance_ = new StreamCore();
  StreamControl::default_instance_ = new StreamControl();
  ProtocolId::default_instance_ = new ProtocolId();
  Protocol::default_instance_ = new Protocol();
  Stream::default_instance_ = new Stream();
  Void::default_instance_ = new Void();
  Ack::default_instance_ = new Ack();
  PortId::default_instance_ = new PortId();
  PortIdList::default_instance_ = new PortIdList();
  StreamIdList::default_instance_ = new StreamIdList();
  Port::default_instance_ = new Port();
  PortConfigList::default_instance_ = new PortConfigList();
  StreamConfigList::default_instance_ = new StreamConfigList();
  CaptureBuffer::default_instance_ = new CaptureBuffer();
  CaptureBufferList::default_instance_ = new CaptureBufferList();
  PortState::default_instance_ = new PortState();
  PortStats::default_instance_ = new PortStats();
  PortStatsList::default_instance_ = new PortStatsList();
  VersionInfo::default_instance_->InitAsDefaultInstance();
  VersionCompatibility::default_instance_->InitAsDefaultInstance();
  StreamId::default_instance_->InitAsDefaultInstance();
  StreamCore::default_instance_->InitAsDefaultInstance();
  StreamControl::default_instance_->InitAsDefaultInstance();
  ProtocolId::default_instance_->InitAsDefaultInstance();
  Protocol::default_instance_->InitAsDefaultInstance();
  Stream::default_instance_->InitAsDefaultInstance();
  Void::default_instance_->InitAsDefaultInstance();
  Ack::default_instance_->InitAsDefaultInstance();
  PortId::default_instance_->InitAsDefaultInstance();
  PortIdList::default_instance_->InitAsDefaultInstance();
  StreamIdList::default_instance_->InitAsDefaultInstance();
  Port::default_instance_->InitAsDefaultInstance();
  PortConfigList::default_instance_->InitAsDefaultInstance();
  StreamConfigList::default_instance_->InitAsDefaultInstance();
  CaptureBuffer::default_instance_->InitAsDefaultInstance();
  CaptureBufferList::default_instance_->InitAsDefaultInstance();
  PortState::default_instance_->InitAsDefaultInstance();
  PortStats::default_instance_->InitAsDefaultInstance();
  PortStatsList::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_protocol_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_protocol_2eproto {
  StaticDescriptorInitializer_protocol_2eproto() {
    protobuf_AddDesc_protocol_2eproto();
  }
} static_descriptor_initializer_protocol_2eproto_;

const ::google::protobuf::EnumDescriptor* TransmitMode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransmitMode_descriptor_;
}
bool TransmitMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* LinkState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LinkState_descriptor_;
}
bool LinkState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int VersionInfo::kVersionFieldNumber;
#endif  // !_MSC_VER

VersionInfo::VersionInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VersionInfo::InitAsDefaultInstance() {
}

VersionInfo::VersionInfo(const VersionInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VersionInfo::SharedCtor() {
  _cached_size_ = 0;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VersionInfo::~VersionInfo() {
  SharedDtor();
}

void VersionInfo::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (this != default_instance_) {
  }
}

void VersionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VersionInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionInfo_descriptor_;
}

const VersionInfo& VersionInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

VersionInfo* VersionInfo::default_instance_ = NULL;

VersionInfo* VersionInfo::New() const {
  return new VersionInfo;
}

void VersionInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VersionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VersionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->version(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VersionInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->version(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VersionInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VersionInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VersionInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VersionInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VersionInfo::MergeFrom(const VersionInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VersionInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VersionInfo::CopyFrom(const VersionInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void VersionInfo::Swap(VersionInfo* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VersionInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VersionInfo_descriptor_;
  metadata.reflection = VersionInfo_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* VersionCompatibility_Compatibility_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionCompatibility_Compatibility_descriptor_;
}
bool VersionCompatibility_Compatibility_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const VersionCompatibility_Compatibility VersionCompatibility::kIncompatible;
const VersionCompatibility_Compatibility VersionCompatibility::kCompatible;
const VersionCompatibility_Compatibility VersionCompatibility::Compatibility_MIN;
const VersionCompatibility_Compatibility VersionCompatibility::Compatibility_MAX;
const int VersionCompatibility::Compatibility_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int VersionCompatibility::kResultFieldNumber;
const int VersionCompatibility::kNotesFieldNumber;
#endif  // !_MSC_VER

VersionCompatibility::VersionCompatibility()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VersionCompatibility::InitAsDefaultInstance() {
}

VersionCompatibility::VersionCompatibility(const VersionCompatibility& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VersionCompatibility::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VersionCompatibility::~VersionCompatibility() {
  SharedDtor();
}

void VersionCompatibility::SharedDtor() {
  if (notes_ != &::google::protobuf::internal::kEmptyString) {
    delete notes_;
  }
  if (this != default_instance_) {
  }
}

void VersionCompatibility::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VersionCompatibility::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionCompatibility_descriptor_;
}

const VersionCompatibility& VersionCompatibility::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

VersionCompatibility* VersionCompatibility::default_instance_ = NULL;

VersionCompatibility* VersionCompatibility::New() const {
  return new VersionCompatibility;
}

void VersionCompatibility::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_notes()) {
      if (notes_ != &::google::protobuf::internal::kEmptyString) {
        notes_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VersionCompatibility::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .OstProto.VersionCompatibility.Compatibility result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::OstProto::VersionCompatibility_Compatibility_IsValid(value)) {
            set_result(static_cast< ::OstProto::VersionCompatibility_Compatibility >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_notes;
        break;
      }
      
      // optional string notes = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_notes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_notes()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->notes().data(), this->notes().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VersionCompatibility::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .OstProto.VersionCompatibility.Compatibility result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }
  
  // optional string notes = 2;
  if (has_notes()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->notes().data(), this->notes().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->notes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VersionCompatibility::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .OstProto.VersionCompatibility.Compatibility result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }
  
  // optional string notes = 2;
  if (has_notes()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->notes().data(), this->notes().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->notes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VersionCompatibility::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .OstProto.VersionCompatibility.Compatibility result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }
    
    // optional string notes = 2;
    if (has_notes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->notes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VersionCompatibility::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VersionCompatibility* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VersionCompatibility*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VersionCompatibility::MergeFrom(const VersionCompatibility& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_notes()) {
      set_notes(from.notes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VersionCompatibility::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VersionCompatibility::CopyFrom(const VersionCompatibility& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionCompatibility::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void VersionCompatibility::Swap(VersionCompatibility* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(notes_, other->notes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VersionCompatibility::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VersionCompatibility_descriptor_;
  metadata.reflection = VersionCompatibility_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StreamId::kIdFieldNumber;
#endif  // !_MSC_VER

StreamId::StreamId()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StreamId::InitAsDefaultInstance() {
}

StreamId::StreamId(const StreamId& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StreamId::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StreamId::~StreamId() {
  SharedDtor();
}

void StreamId::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StreamId::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StreamId::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamId_descriptor_;
}

const StreamId& StreamId::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

StreamId* StreamId::default_instance_ = NULL;

StreamId* StreamId::New() const {
  return new StreamId;
}

void StreamId::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StreamId::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StreamId::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StreamId::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StreamId::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StreamId::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StreamId* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StreamId*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StreamId::MergeFrom(const StreamId& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StreamId::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StreamId::CopyFrom(const StreamId& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamId::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void StreamId::Swap(StreamId* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StreamId::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StreamId_descriptor_;
  metadata.reflection = StreamId_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* StreamCore_FrameLengthMode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamCore_FrameLengthMode_descriptor_;
}
bool StreamCore_FrameLengthMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const StreamCore_FrameLengthMode StreamCore::e_fl_fixed;
const StreamCore_FrameLengthMode StreamCore::e_fl_inc;
const StreamCore_FrameLengthMode StreamCore::e_fl_dec;
const StreamCore_FrameLengthMode StreamCore::e_fl_random;
const StreamCore_FrameLengthMode StreamCore::FrameLengthMode_MIN;
const StreamCore_FrameLengthMode StreamCore::FrameLengthMode_MAX;
const int StreamCore::FrameLengthMode_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int StreamCore::kNameFieldNumber;
const int StreamCore::kIsEnabledFieldNumber;
const int StreamCore::kOrdinalFieldNumber;
const int StreamCore::kLenModeFieldNumber;
const int StreamCore::kFrameLenFieldNumber;
const int StreamCore::kFrameLenMinFieldNumber;
const int StreamCore::kFrameLenMaxFieldNumber;
#endif  // !_MSC_VER

StreamCore::StreamCore()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StreamCore::InitAsDefaultInstance() {
}

StreamCore::StreamCore(const StreamCore& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StreamCore::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  is_enabled_ = false;
  ordinal_ = 0u;
  len_mode_ = 0;
  frame_len_ = 64u;
  frame_len_min_ = 64u;
  frame_len_max_ = 1518u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StreamCore::~StreamCore() {
  SharedDtor();
}

void StreamCore::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void StreamCore::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StreamCore::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamCore_descriptor_;
}

const StreamCore& StreamCore::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

StreamCore* StreamCore::default_instance_ = NULL;

StreamCore* StreamCore::New() const {
  return new StreamCore;
}

void StreamCore::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    is_enabled_ = false;
    ordinal_ = 0u;
    len_mode_ = 0;
    frame_len_ = 64u;
    frame_len_min_ = 64u;
    frame_len_max_ = 1518u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StreamCore::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_enabled;
        break;
      }
      
      // optional bool is_enabled = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_enabled_)));
          set_has_is_enabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ordinal;
        break;
      }
      
      // optional uint32 ordinal = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ordinal:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ordinal_)));
          set_has_ordinal();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_len_mode;
        break;
      }
      
      // optional .OstProto.StreamCore.FrameLengthMode len_mode = 14 [default = e_fl_fixed];
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_len_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::OstProto::StreamCore_FrameLengthMode_IsValid(value)) {
            set_len_mode(static_cast< ::OstProto::StreamCore_FrameLengthMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(14, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_frame_len;
        break;
      }
      
      // optional uint32 frame_len = 15 [default = 64];
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_frame_len:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frame_len_)));
          set_has_frame_len();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_frame_len_min;
        break;
      }
      
      // optional uint32 frame_len_min = 16 [default = 64];
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_frame_len_min:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frame_len_min_)));
          set_has_frame_len_min();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_frame_len_max;
        break;
      }
      
      // optional uint32 frame_len_max = 17 [default = 1518];
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_frame_len_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frame_len_max_)));
          set_has_frame_len_max();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StreamCore::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional bool is_enabled = 2;
  if (has_is_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_enabled(), output);
  }
  
  // optional uint32 ordinal = 3;
  if (has_ordinal()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->ordinal(), output);
  }
  
  // optional .OstProto.StreamCore.FrameLengthMode len_mode = 14 [default = e_fl_fixed];
  if (has_len_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      14, this->len_mode(), output);
  }
  
  // optional uint32 frame_len = 15 [default = 64];
  if (has_frame_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->frame_len(), output);
  }
  
  // optional uint32 frame_len_min = 16 [default = 64];
  if (has_frame_len_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->frame_len_min(), output);
  }
  
  // optional uint32 frame_len_max = 17 [default = 1518];
  if (has_frame_len_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(17, this->frame_len_max(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StreamCore::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional bool is_enabled = 2;
  if (has_is_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->is_enabled(), target);
  }
  
  // optional uint32 ordinal = 3;
  if (has_ordinal()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->ordinal(), target);
  }
  
  // optional .OstProto.StreamCore.FrameLengthMode len_mode = 14 [default = e_fl_fixed];
  if (has_len_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      14, this->len_mode(), target);
  }
  
  // optional uint32 frame_len = 15 [default = 64];
  if (has_frame_len()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->frame_len(), target);
  }
  
  // optional uint32 frame_len_min = 16 [default = 64];
  if (has_frame_len_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(16, this->frame_len_min(), target);
  }
  
  // optional uint32 frame_len_max = 17 [default = 1518];
  if (has_frame_len_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(17, this->frame_len_max(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StreamCore::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional bool is_enabled = 2;
    if (has_is_enabled()) {
      total_size += 1 + 1;
    }
    
    // optional uint32 ordinal = 3;
    if (has_ordinal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ordinal());
    }
    
    // optional .OstProto.StreamCore.FrameLengthMode len_mode = 14 [default = e_fl_fixed];
    if (has_len_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->len_mode());
    }
    
    // optional uint32 frame_len = 15 [default = 64];
    if (has_frame_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frame_len());
    }
    
    // optional uint32 frame_len_min = 16 [default = 64];
    if (has_frame_len_min()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frame_len_min());
    }
    
    // optional uint32 frame_len_max = 17 [default = 1518];
    if (has_frame_len_max()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frame_len_max());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StreamCore::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StreamCore* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StreamCore*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StreamCore::MergeFrom(const StreamCore& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_is_enabled()) {
      set_is_enabled(from.is_enabled());
    }
    if (from.has_ordinal()) {
      set_ordinal(from.ordinal());
    }
    if (from.has_len_mode()) {
      set_len_mode(from.len_mode());
    }
    if (from.has_frame_len()) {
      set_frame_len(from.frame_len());
    }
    if (from.has_frame_len_min()) {
      set_frame_len_min(from.frame_len_min());
    }
    if (from.has_frame_len_max()) {
      set_frame_len_max(from.frame_len_max());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StreamCore::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StreamCore::CopyFrom(const StreamCore& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamCore::IsInitialized() const {
  
  return true;
}

void StreamCore::Swap(StreamCore* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(is_enabled_, other->is_enabled_);
    std::swap(ordinal_, other->ordinal_);
    std::swap(len_mode_, other->len_mode_);
    std::swap(frame_len_, other->frame_len_);
    std::swap(frame_len_min_, other->frame_len_min_);
    std::swap(frame_len_max_, other->frame_len_max_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StreamCore::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StreamCore_descriptor_;
  metadata.reflection = StreamCore_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* StreamControl_SendUnit_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamControl_SendUnit_descriptor_;
}
bool StreamControl_SendUnit_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const StreamControl_SendUnit StreamControl::e_su_packets;
const StreamControl_SendUnit StreamControl::e_su_bursts;
const StreamControl_SendUnit StreamControl::SendUnit_MIN;
const StreamControl_SendUnit StreamControl::SendUnit_MAX;
const int StreamControl::SendUnit_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* StreamControl_SendMode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamControl_SendMode_descriptor_;
}
bool StreamControl_SendMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const StreamControl_SendMode StreamControl::e_sm_fixed;
const StreamControl_SendMode StreamControl::e_sm_continuous;
const StreamControl_SendMode StreamControl::SendMode_MIN;
const StreamControl_SendMode StreamControl::SendMode_MAX;
const int StreamControl::SendMode_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* StreamControl_NextWhat_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamControl_NextWhat_descriptor_;
}
bool StreamControl_NextWhat_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const StreamControl_NextWhat StreamControl::e_nw_stop;
const StreamControl_NextWhat StreamControl::e_nw_goto_next;
const StreamControl_NextWhat StreamControl::e_nw_goto_id;
const StreamControl_NextWhat StreamControl::NextWhat_MIN;
const StreamControl_NextWhat StreamControl::NextWhat_MAX;
const int StreamControl::NextWhat_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int StreamControl::kUnitFieldNumber;
const int StreamControl::kModeFieldNumber;
const int StreamControl::kNumPacketsFieldNumber;
const int StreamControl::kNumBurstsFieldNumber;
const int StreamControl::kPacketsPerBurstFieldNumber;
const int StreamControl::kNextFieldNumber;
const int StreamControl::kOBSOLETEPacketsPerSecFieldNumber;
const int StreamControl::kOBSOLETEBurstsPerSecFieldNumber;
const int StreamControl::kPacketsPerSecFieldNumber;
const int StreamControl::kBurstsPerSecFieldNumber;
#endif  // !_MSC_VER

StreamControl::StreamControl()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StreamControl::InitAsDefaultInstance() {
}

StreamControl::StreamControl(const StreamControl& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StreamControl::SharedCtor() {
  _cached_size_ = 0;
  unit_ = 0;
  mode_ = 0;
  num_packets_ = 1u;
  num_bursts_ = 1u;
  packets_per_burst_ = 10u;
  next_ = 1;
  obsolete_packets_per_sec_ = 1u;
  obsolete_bursts_per_sec_ = 1u;
  packets_per_sec_ = 1;
  bursts_per_sec_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StreamControl::~StreamControl() {
  SharedDtor();
}

void StreamControl::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StreamControl::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StreamControl::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamControl_descriptor_;
}

const StreamControl& StreamControl::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

StreamControl* StreamControl::default_instance_ = NULL;

StreamControl* StreamControl::New() const {
  return new StreamControl;
}

void StreamControl::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    unit_ = 0;
    mode_ = 0;
    num_packets_ = 1u;
    num_bursts_ = 1u;
    packets_per_burst_ = 10u;
    next_ = 1;
    obsolete_packets_per_sec_ = 1u;
    obsolete_bursts_per_sec_ = 1u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    packets_per_sec_ = 1;
    bursts_per_sec_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StreamControl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .OstProto.StreamControl.SendUnit unit = 1 [default = e_su_packets];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::OstProto::StreamControl_SendUnit_IsValid(value)) {
            set_unit(static_cast< ::OstProto::StreamControl_SendUnit >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mode;
        break;
      }
      
      // optional .OstProto.StreamControl.SendMode mode = 2 [default = e_sm_fixed];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::OstProto::StreamControl_SendMode_IsValid(value)) {
            set_mode(static_cast< ::OstProto::StreamControl_SendMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_num_packets;
        break;
      }
      
      // optional uint32 num_packets = 3 [default = 1];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num_packets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_packets_)));
          set_has_num_packets();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_num_bursts;
        break;
      }
      
      // optional uint32 num_bursts = 4 [default = 1];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num_bursts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_bursts_)));
          set_has_num_bursts();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_packets_per_burst;
        break;
      }
      
      // optional uint32 packets_per_burst = 5 [default = 10];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_packets_per_burst:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &packets_per_burst_)));
          set_has_packets_per_burst();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_next;
        break;
      }
      
      // optional .OstProto.StreamControl.NextWhat next = 6 [default = e_nw_goto_next];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_next:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::OstProto::StreamControl_NextWhat_IsValid(value)) {
            set_next(static_cast< ::OstProto::StreamControl_NextWhat >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_OBSOLETE_packets_per_sec;
        break;
      }
      
      // optional uint32 OBSOLETE_packets_per_sec = 7 [default = 1, deprecated = true];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_OBSOLETE_packets_per_sec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &obsolete_packets_per_sec_)));
          set_has_obsolete_packets_per_sec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_OBSOLETE_bursts_per_sec;
        break;
      }
      
      // optional uint32 OBSOLETE_bursts_per_sec = 8 [default = 1, deprecated = true];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_OBSOLETE_bursts_per_sec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &obsolete_bursts_per_sec_)));
          set_has_obsolete_bursts_per_sec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(73)) goto parse_packets_per_sec;
        break;
      }
      
      // optional double packets_per_sec = 9 [default = 1];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_packets_per_sec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &packets_per_sec_)));
          set_has_packets_per_sec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(81)) goto parse_bursts_per_sec;
        break;
      }
      
      // optional double bursts_per_sec = 10 [default = 1];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_bursts_per_sec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &bursts_per_sec_)));
          set_has_bursts_per_sec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StreamControl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .OstProto.StreamControl.SendUnit unit = 1 [default = e_su_packets];
  if (has_unit()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->unit(), output);
  }
  
  // optional .OstProto.StreamControl.SendMode mode = 2 [default = e_sm_fixed];
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->mode(), output);
  }
  
  // optional uint32 num_packets = 3 [default = 1];
  if (has_num_packets()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->num_packets(), output);
  }
  
  // optional uint32 num_bursts = 4 [default = 1];
  if (has_num_bursts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->num_bursts(), output);
  }
  
  // optional uint32 packets_per_burst = 5 [default = 10];
  if (has_packets_per_burst()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->packets_per_burst(), output);
  }
  
  // optional .OstProto.StreamControl.NextWhat next = 6 [default = e_nw_goto_next];
  if (has_next()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->next(), output);
  }
  
  // optional uint32 OBSOLETE_packets_per_sec = 7 [default = 1, deprecated = true];
  if (has_obsolete_packets_per_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->obsolete_packets_per_sec(), output);
  }
  
  // optional uint32 OBSOLETE_bursts_per_sec = 8 [default = 1, deprecated = true];
  if (has_obsolete_bursts_per_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->obsolete_bursts_per_sec(), output);
  }
  
  // optional double packets_per_sec = 9 [default = 1];
  if (has_packets_per_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->packets_per_sec(), output);
  }
  
  // optional double bursts_per_sec = 10 [default = 1];
  if (has_bursts_per_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->bursts_per_sec(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StreamControl::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .OstProto.StreamControl.SendUnit unit = 1 [default = e_su_packets];
  if (has_unit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->unit(), target);
  }
  
  // optional .OstProto.StreamControl.SendMode mode = 2 [default = e_sm_fixed];
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->mode(), target);
  }
  
  // optional uint32 num_packets = 3 [default = 1];
  if (has_num_packets()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->num_packets(), target);
  }
  
  // optional uint32 num_bursts = 4 [default = 1];
  if (has_num_bursts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->num_bursts(), target);
  }
  
  // optional uint32 packets_per_burst = 5 [default = 10];
  if (has_packets_per_burst()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->packets_per_burst(), target);
  }
  
  // optional .OstProto.StreamControl.NextWhat next = 6 [default = e_nw_goto_next];
  if (has_next()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->next(), target);
  }
  
  // optional uint32 OBSOLETE_packets_per_sec = 7 [default = 1, deprecated = true];
  if (has_obsolete_packets_per_sec()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->obsolete_packets_per_sec(), target);
  }
  
  // optional uint32 OBSOLETE_bursts_per_sec = 8 [default = 1, deprecated = true];
  if (has_obsolete_bursts_per_sec()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->obsolete_bursts_per_sec(), target);
  }
  
  // optional double packets_per_sec = 9 [default = 1];
  if (has_packets_per_sec()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->packets_per_sec(), target);
  }
  
  // optional double bursts_per_sec = 10 [default = 1];
  if (has_bursts_per_sec()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->bursts_per_sec(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StreamControl::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .OstProto.StreamControl.SendUnit unit = 1 [default = e_su_packets];
    if (has_unit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->unit());
    }
    
    // optional .OstProto.StreamControl.SendMode mode = 2 [default = e_sm_fixed];
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }
    
    // optional uint32 num_packets = 3 [default = 1];
    if (has_num_packets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_packets());
    }
    
    // optional uint32 num_bursts = 4 [default = 1];
    if (has_num_bursts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_bursts());
    }
    
    // optional uint32 packets_per_burst = 5 [default = 10];
    if (has_packets_per_burst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->packets_per_burst());
    }
    
    // optional .OstProto.StreamControl.NextWhat next = 6 [default = e_nw_goto_next];
    if (has_next()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->next());
    }
    
    // optional uint32 OBSOLETE_packets_per_sec = 7 [default = 1, deprecated = true];
    if (has_obsolete_packets_per_sec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->obsolete_packets_per_sec());
    }
    
    // optional uint32 OBSOLETE_bursts_per_sec = 8 [default = 1, deprecated = true];
    if (has_obsolete_bursts_per_sec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->obsolete_bursts_per_sec());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional double packets_per_sec = 9 [default = 1];
    if (has_packets_per_sec()) {
      total_size += 1 + 8;
    }
    
    // optional double bursts_per_sec = 10 [default = 1];
    if (has_bursts_per_sec()) {
      total_size += 1 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StreamControl::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StreamControl* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StreamControl*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StreamControl::MergeFrom(const StreamControl& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unit()) {
      set_unit(from.unit());
    }
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_num_packets()) {
      set_num_packets(from.num_packets());
    }
    if (from.has_num_bursts()) {
      set_num_bursts(from.num_bursts());
    }
    if (from.has_packets_per_burst()) {
      set_packets_per_burst(from.packets_per_burst());
    }
    if (from.has_next()) {
      set_next(from.next());
    }
    if (from.has_obsolete_packets_per_sec()) {
      set_obsolete_packets_per_sec(from.obsolete_packets_per_sec());
    }
    if (from.has_obsolete_bursts_per_sec()) {
      set_obsolete_bursts_per_sec(from.obsolete_bursts_per_sec());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_packets_per_sec()) {
      set_packets_per_sec(from.packets_per_sec());
    }
    if (from.has_bursts_per_sec()) {
      set_bursts_per_sec(from.bursts_per_sec());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StreamControl::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StreamControl::CopyFrom(const StreamControl& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamControl::IsInitialized() const {
  
  return true;
}

void StreamControl::Swap(StreamControl* other) {
  if (other != this) {
    std::swap(unit_, other->unit_);
    std::swap(mode_, other->mode_);
    std::swap(num_packets_, other->num_packets_);
    std::swap(num_bursts_, other->num_bursts_);
    std::swap(packets_per_burst_, other->packets_per_burst_);
    std::swap(next_, other->next_);
    std::swap(obsolete_packets_per_sec_, other->obsolete_packets_per_sec_);
    std::swap(obsolete_bursts_per_sec_, other->obsolete_bursts_per_sec_);
    std::swap(packets_per_sec_, other->packets_per_sec_);
    std::swap(bursts_per_sec_, other->bursts_per_sec_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StreamControl::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StreamControl_descriptor_;
  metadata.reflection = StreamControl_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProtocolId::kIdFieldNumber;
#endif  // !_MSC_VER

ProtocolId::ProtocolId()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProtocolId::InitAsDefaultInstance() {
}

ProtocolId::ProtocolId(const ProtocolId& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProtocolId::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProtocolId::~ProtocolId() {
  SharedDtor();
}

void ProtocolId::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProtocolId::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProtocolId::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProtocolId_descriptor_;
}

const ProtocolId& ProtocolId::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

ProtocolId* ProtocolId::default_instance_ = NULL;

ProtocolId* ProtocolId::New() const {
  return new ProtocolId;
}

void ProtocolId::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProtocolId::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProtocolId::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProtocolId::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProtocolId::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProtocolId::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProtocolId* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProtocolId*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProtocolId::MergeFrom(const ProtocolId& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProtocolId::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProtocolId::CopyFrom(const ProtocolId& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtocolId::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void ProtocolId::Swap(ProtocolId* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProtocolId::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProtocolId_descriptor_;
  metadata.reflection = ProtocolId_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Protocol_k_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Protocol_k_descriptor_;
}
bool Protocol_k_IsValid(int value) {
  switch(value) {
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 300:
    case 301:
    case 302:
    case 303:
    case 304:
    case 305:
    case 306:
    case 400:
    case 401:
    case 402:
    case 403:
    case 404:
    case 500:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Protocol_k Protocol::kMacFieldNumber;
const Protocol_k Protocol::kPayloadFieldNumber;
const Protocol_k Protocol::kSampleFieldNumber;
const Protocol_k Protocol::kUserScriptFieldNumber;
const Protocol_k Protocol::kHexDumpFieldNumber;
const Protocol_k Protocol::kEth2FieldNumber;
const Protocol_k Protocol::kDot3FieldNumber;
const Protocol_k Protocol::kLlcFieldNumber;
const Protocol_k Protocol::kSnapFieldNumber;
const Protocol_k Protocol::kSvlanFieldNumber;
const Protocol_k Protocol::kVlanFieldNumber;
const Protocol_k Protocol::kDot2LlcFieldNumber;
const Protocol_k Protocol::kDot2SnapFieldNumber;
const Protocol_k Protocol::kVlanStackFieldNumber;
const Protocol_k Protocol::kArpFieldNumber;
const Protocol_k Protocol::kIp4FieldNumber;
const Protocol_k Protocol::kIp6FieldNumber;
const Protocol_k Protocol::kIp6over4FieldNumber;
const Protocol_k Protocol::kIp4over6FieldNumber;
const Protocol_k Protocol::kIp4over4FieldNumber;
const Protocol_k Protocol::kIp6over6FieldNumber;
const Protocol_k Protocol::kTcpFieldNumber;
const Protocol_k Protocol::kUdpFieldNumber;
const Protocol_k Protocol::kIcmpFieldNumber;
const Protocol_k Protocol::kIgmpFieldNumber;
const Protocol_k Protocol::kMldFieldNumber;
const Protocol_k Protocol::kTextProtocolFieldNumber;
const Protocol_k Protocol::k_MIN;
const Protocol_k Protocol::k_MAX;
const int Protocol::k_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Protocol::kProtocolIdFieldNumber;
#endif  // !_MSC_VER

Protocol::Protocol()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Protocol::InitAsDefaultInstance() {
  protocol_id_ = const_cast< ::OstProto::ProtocolId*>(&::OstProto::ProtocolId::default_instance());
}

Protocol::Protocol(const Protocol& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Protocol::SharedCtor() {
  _cached_size_ = 0;
  protocol_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Protocol::~Protocol() {
  SharedDtor();
}

void Protocol::SharedDtor() {
  if (this != default_instance_) {
    delete protocol_id_;
  }
}

void Protocol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Protocol::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Protocol_descriptor_;
}

const Protocol& Protocol::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

Protocol* Protocol::default_instance_ = NULL;

Protocol* Protocol::New() const {
  return new Protocol;
}

void Protocol::Clear() {
  _extensions_.Clear();
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_protocol_id()) {
      if (protocol_id_ != NULL) protocol_id_->::OstProto::ProtocolId::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Protocol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .OstProto.ProtocolId protocol_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_protocol_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        if ((800u <= tag && tag < 1600u) ||
            (1600u <= tag && tag < 4008u)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      mutable_unknown_fields()));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Protocol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .OstProto.ProtocolId protocol_id = 1;
  if (has_protocol_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->protocol_id(), output);
  }
  
  // Extension range [100, 200)
  _extensions_.SerializeWithCachedSizes(
      100, 200, output);
  
  // Extension range [200, 501)
  _extensions_.SerializeWithCachedSizes(
      200, 501, output);
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Protocol::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .OstProto.ProtocolId protocol_id = 1;
  if (has_protocol_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->protocol_id(), target);
  }
  
  // Extension range [100, 200)
  target = _extensions_.SerializeWithCachedSizesToArray(
      100, 200, target);
  
  // Extension range [200, 501)
  target = _extensions_.SerializeWithCachedSizesToArray(
      200, 501, target);
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Protocol::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .OstProto.ProtocolId protocol_id = 1;
    if (has_protocol_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->protocol_id());
    }
    
  }
  total_size += _extensions_.ByteSize();
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Protocol::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Protocol* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Protocol*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Protocol::MergeFrom(const Protocol& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_protocol_id()) {
      mutable_protocol_id()->::OstProto::ProtocolId::MergeFrom(from.protocol_id());
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Protocol::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Protocol::CopyFrom(const Protocol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Protocol::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_protocol_id()) {
    if (!this->protocol_id().IsInitialized()) return false;
  }
  
  if (!_extensions_.IsInitialized()) return false;  return true;
}

void Protocol::Swap(Protocol* other) {
  if (other != this) {
    std::swap(protocol_id_, other->protocol_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
    _extensions_.Swap(&other->_extensions_);
  }
}

::google::protobuf::Metadata Protocol::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Protocol_descriptor_;
  metadata.reflection = Protocol_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Stream::kStreamIdFieldNumber;
const int Stream::kCoreFieldNumber;
const int Stream::kControlFieldNumber;
const int Stream::kProtocolFieldNumber;
#endif  // !_MSC_VER

Stream::Stream()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Stream::InitAsDefaultInstance() {
  stream_id_ = const_cast< ::OstProto::StreamId*>(&::OstProto::StreamId::default_instance());
  core_ = const_cast< ::OstProto::StreamCore*>(&::OstProto::StreamCore::default_instance());
  control_ = const_cast< ::OstProto::StreamControl*>(&::OstProto::StreamControl::default_instance());
}

Stream::Stream(const Stream& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Stream::SharedCtor() {
  _cached_size_ = 0;
  stream_id_ = NULL;
  core_ = NULL;
  control_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Stream::~Stream() {
  SharedDtor();
}

void Stream::SharedDtor() {
  if (this != default_instance_) {
    delete stream_id_;
    delete core_;
    delete control_;
  }
}

void Stream::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Stream::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Stream_descriptor_;
}

const Stream& Stream::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

Stream* Stream::default_instance_ = NULL;

Stream* Stream::New() const {
  return new Stream;
}

void Stream::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_stream_id()) {
      if (stream_id_ != NULL) stream_id_->::OstProto::StreamId::Clear();
    }
    if (has_core()) {
      if (core_ != NULL) core_->::OstProto::StreamCore::Clear();
    }
    if (has_control()) {
      if (control_ != NULL) control_->::OstProto::StreamControl::Clear();
    }
  }
  protocol_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Stream::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .OstProto.StreamId stream_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stream_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_core;
        break;
      }
      
      // optional .OstProto.StreamCore core = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_core:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_core()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_control;
        break;
      }
      
      // optional .OstProto.StreamControl control = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_control:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_control()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_protocol;
        break;
      }
      
      // repeated .OstProto.Protocol protocol = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_protocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_protocol()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_protocol;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Stream::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .OstProto.StreamId stream_id = 1;
  if (has_stream_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->stream_id(), output);
  }
  
  // optional .OstProto.StreamCore core = 2;
  if (has_core()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->core(), output);
  }
  
  // optional .OstProto.StreamControl control = 3;
  if (has_control()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->control(), output);
  }
  
  // repeated .OstProto.Protocol protocol = 4;
  for (int i = 0; i < this->protocol_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->protocol(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Stream::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .OstProto.StreamId stream_id = 1;
  if (has_stream_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->stream_id(), target);
  }
  
  // optional .OstProto.StreamCore core = 2;
  if (has_core()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->core(), target);
  }
  
  // optional .OstProto.StreamControl control = 3;
  if (has_control()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->control(), target);
  }
  
  // repeated .OstProto.Protocol protocol = 4;
  for (int i = 0; i < this->protocol_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->protocol(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Stream::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .OstProto.StreamId stream_id = 1;
    if (has_stream_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stream_id());
    }
    
    // optional .OstProto.StreamCore core = 2;
    if (has_core()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->core());
    }
    
    // optional .OstProto.StreamControl control = 3;
    if (has_control()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->control());
    }
    
  }
  // repeated .OstProto.Protocol protocol = 4;
  total_size += 1 * this->protocol_size();
  for (int i = 0; i < this->protocol_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->protocol(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Stream::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Stream* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Stream*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Stream::MergeFrom(const Stream& from) {
  GOOGLE_CHECK_NE(&from, this);
  protocol_.MergeFrom(from.protocol_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stream_id()) {
      mutable_stream_id()->::OstProto::StreamId::MergeFrom(from.stream_id());
    }
    if (from.has_core()) {
      mutable_core()->::OstProto::StreamCore::MergeFrom(from.core());
    }
    if (from.has_control()) {
      mutable_control()->::OstProto::StreamControl::MergeFrom(from.control());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Stream::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Stream::CopyFrom(const Stream& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stream::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_stream_id()) {
    if (!this->stream_id().IsInitialized()) return false;
  }
  for (int i = 0; i < protocol_size(); i++) {
    if (!this->protocol(i).IsInitialized()) return false;
  }
  return true;
}

void Stream::Swap(Stream* other) {
  if (other != this) {
    std::swap(stream_id_, other->stream_id_);
    std::swap(core_, other->core_);
    std::swap(control_, other->control_);
    protocol_.Swap(&other->protocol_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Stream::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Stream_descriptor_;
  metadata.reflection = Stream_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Void::Void()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Void::InitAsDefaultInstance() {
}

Void::Void(const Void& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Void::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Void::~Void() {
  SharedDtor();
}

void Void::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Void::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Void::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Void_descriptor_;
}

const Void& Void::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

Void* Void::default_instance_ = NULL;

Void* Void::New() const {
  return new Void;
}

void Void::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Void::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void Void::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Void::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Void::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Void::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Void* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Void*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Void::MergeFrom(const Void& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Void::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Void::CopyFrom(const Void& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Void::IsInitialized() const {
  
  return true;
}

void Void::Swap(Void* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Void::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Void_descriptor_;
  metadata.reflection = Void_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Ack::Ack()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Ack::InitAsDefaultInstance() {
}

Ack::Ack(const Ack& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Ack::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ack::~Ack() {
  SharedDtor();
}

void Ack::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Ack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Ack::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Ack_descriptor_;
}

const Ack& Ack::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

Ack* Ack::default_instance_ = NULL;

Ack* Ack::New() const {
  return new Ack;
}

void Ack::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Ack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void Ack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Ack::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Ack::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ack::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Ack* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Ack*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Ack::MergeFrom(const Ack& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Ack::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ack::CopyFrom(const Ack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ack::IsInitialized() const {
  
  return true;
}

void Ack::Swap(Ack* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Ack::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Ack_descriptor_;
  metadata.reflection = Ack_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PortId::kIdFieldNumber;
#endif  // !_MSC_VER

PortId::PortId()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PortId::InitAsDefaultInstance() {
}

PortId::PortId(const PortId& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PortId::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PortId::~PortId() {
  SharedDtor();
}

void PortId::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PortId::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PortId::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PortId_descriptor_;
}

const PortId& PortId::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

PortId* PortId::default_instance_ = NULL;

PortId* PortId::New() const {
  return new PortId;
}

void PortId::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PortId::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PortId::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PortId::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PortId::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PortId::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PortId* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PortId*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PortId::MergeFrom(const PortId& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PortId::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PortId::CopyFrom(const PortId& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortId::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void PortId::Swap(PortId* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PortId::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PortId_descriptor_;
  metadata.reflection = PortId_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PortIdList::kPortIdFieldNumber;
#endif  // !_MSC_VER

PortIdList::PortIdList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PortIdList::InitAsDefaultInstance() {
}

PortIdList::PortIdList(const PortIdList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PortIdList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PortIdList::~PortIdList() {
  SharedDtor();
}

void PortIdList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PortIdList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PortIdList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PortIdList_descriptor_;
}

const PortIdList& PortIdList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

PortIdList* PortIdList::default_instance_ = NULL;

PortIdList* PortIdList::New() const {
  return new PortIdList;
}

void PortIdList::Clear() {
  port_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PortIdList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .OstProto.PortId port_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_port_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_port_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_port_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PortIdList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .OstProto.PortId port_id = 1;
  for (int i = 0; i < this->port_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->port_id(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PortIdList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .OstProto.PortId port_id = 1;
  for (int i = 0; i < this->port_id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->port_id(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PortIdList::ByteSize() const {
  int total_size = 0;
  
  // repeated .OstProto.PortId port_id = 1;
  total_size += 1 * this->port_id_size();
  for (int i = 0; i < this->port_id_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->port_id(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PortIdList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PortIdList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PortIdList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PortIdList::MergeFrom(const PortIdList& from) {
  GOOGLE_CHECK_NE(&from, this);
  port_id_.MergeFrom(from.port_id_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PortIdList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PortIdList::CopyFrom(const PortIdList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortIdList::IsInitialized() const {
  
  for (int i = 0; i < port_id_size(); i++) {
    if (!this->port_id(i).IsInitialized()) return false;
  }
  return true;
}

void PortIdList::Swap(PortIdList* other) {
  if (other != this) {
    port_id_.Swap(&other->port_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PortIdList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PortIdList_descriptor_;
  metadata.reflection = PortIdList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StreamIdList::kPortIdFieldNumber;
const int StreamIdList::kStreamIdFieldNumber;
#endif  // !_MSC_VER

StreamIdList::StreamIdList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StreamIdList::InitAsDefaultInstance() {
  port_id_ = const_cast< ::OstProto::PortId*>(&::OstProto::PortId::default_instance());
}

StreamIdList::StreamIdList(const StreamIdList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StreamIdList::SharedCtor() {
  _cached_size_ = 0;
  port_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StreamIdList::~StreamIdList() {
  SharedDtor();
}

void StreamIdList::SharedDtor() {
  if (this != default_instance_) {
    delete port_id_;
  }
}

void StreamIdList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StreamIdList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamIdList_descriptor_;
}

const StreamIdList& StreamIdList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

StreamIdList* StreamIdList::default_instance_ = NULL;

StreamIdList* StreamIdList::New() const {
  return new StreamIdList;
}

void StreamIdList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_port_id()) {
      if (port_id_ != NULL) port_id_->::OstProto::PortId::Clear();
    }
  }
  stream_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StreamIdList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .OstProto.PortId port_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_port_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_stream_id;
        break;
      }
      
      // repeated .OstProto.StreamId stream_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_stream_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_stream_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_stream_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StreamIdList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .OstProto.PortId port_id = 1;
  if (has_port_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->port_id(), output);
  }
  
  // repeated .OstProto.StreamId stream_id = 2;
  for (int i = 0; i < this->stream_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->stream_id(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StreamIdList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .OstProto.PortId port_id = 1;
  if (has_port_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->port_id(), target);
  }
  
  // repeated .OstProto.StreamId stream_id = 2;
  for (int i = 0; i < this->stream_id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->stream_id(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StreamIdList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .OstProto.PortId port_id = 1;
    if (has_port_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->port_id());
    }
    
  }
  // repeated .OstProto.StreamId stream_id = 2;
  total_size += 1 * this->stream_id_size();
  for (int i = 0; i < this->stream_id_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->stream_id(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StreamIdList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StreamIdList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StreamIdList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StreamIdList::MergeFrom(const StreamIdList& from) {
  GOOGLE_CHECK_NE(&from, this);
  stream_id_.MergeFrom(from.stream_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port_id()) {
      mutable_port_id()->::OstProto::PortId::MergeFrom(from.port_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StreamIdList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StreamIdList::CopyFrom(const StreamIdList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamIdList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_port_id()) {
    if (!this->port_id().IsInitialized()) return false;
  }
  for (int i = 0; i < stream_id_size(); i++) {
    if (!this->stream_id(i).IsInitialized()) return false;
  }
  return true;
}

void StreamIdList::Swap(StreamIdList* other) {
  if (other != this) {
    std::swap(port_id_, other->port_id_);
    stream_id_.Swap(&other->stream_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StreamIdList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StreamIdList_descriptor_;
  metadata.reflection = StreamIdList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Port::kPortIdFieldNumber;
const int Port::kNameFieldNumber;
const int Port::kDescriptionFieldNumber;
const int Port::kNotesFieldNumber;
const int Port::kIsEnabledFieldNumber;
const int Port::kIsExclusiveControlFieldNumber;
const int Port::kTransmitModeFieldNumber;
#endif  // !_MSC_VER

Port::Port()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Port::InitAsDefaultInstance() {
  port_id_ = const_cast< ::OstProto::PortId*>(&::OstProto::PortId::default_instance());
}

Port::Port(const Port& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Port::SharedCtor() {
  _cached_size_ = 0;
  port_id_ = NULL;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  is_enabled_ = false;
  is_exclusive_control_ = false;
  transmit_mode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Port::~Port() {
  SharedDtor();
}

void Port::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (notes_ != &::google::protobuf::internal::kEmptyString) {
    delete notes_;
  }
  if (this != default_instance_) {
    delete port_id_;
  }
}

void Port::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Port::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Port_descriptor_;
}

const Port& Port::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

Port* Port::default_instance_ = NULL;

Port* Port::New() const {
  return new Port;
}

void Port::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_port_id()) {
      if (port_id_ != NULL) port_id_->::OstProto::PortId::Clear();
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_notes()) {
      if (notes_ != &::google::protobuf::internal::kEmptyString) {
        notes_->clear();
      }
    }
    is_enabled_ = false;
    is_exclusive_control_ = false;
    transmit_mode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Port::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .OstProto.PortId port_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_port_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_description;
        break;
      }
      
      // optional string description = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_notes;
        break;
      }
      
      // optional string notes = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_notes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_notes()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->notes().data(), this->notes().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_is_enabled;
        break;
      }
      
      // optional bool is_enabled = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_enabled_)));
          set_has_is_enabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_is_exclusive_control;
        break;
      }
      
      // optional bool is_exclusive_control = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_exclusive_control:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_exclusive_control_)));
          set_has_is_exclusive_control();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_transmit_mode;
        break;
      }
      
      // optional .OstProto.TransmitMode transmit_mode = 7 [default = kSequentialTransmit];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_transmit_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (OstProto::TransmitMode_IsValid(value)) {
            set_transmit_mode(static_cast< OstProto::TransmitMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Port::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .OstProto.PortId port_id = 1;
  if (has_port_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->port_id(), output);
  }
  
  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  // optional string description = 3;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->description(), output);
  }
  
  // optional string notes = 4;
  if (has_notes()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->notes().data(), this->notes().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->notes(), output);
  }
  
  // optional bool is_enabled = 5;
  if (has_is_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->is_enabled(), output);
  }
  
  // optional bool is_exclusive_control = 6;
  if (has_is_exclusive_control()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->is_exclusive_control(), output);
  }
  
  // optional .OstProto.TransmitMode transmit_mode = 7 [default = kSequentialTransmit];
  if (has_transmit_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->transmit_mode(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Port::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .OstProto.PortId port_id = 1;
  if (has_port_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->port_id(), target);
  }
  
  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }
  
  // optional string description = 3;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->description(), target);
  }
  
  // optional string notes = 4;
  if (has_notes()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->notes().data(), this->notes().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->notes(), target);
  }
  
  // optional bool is_enabled = 5;
  if (has_is_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->is_enabled(), target);
  }
  
  // optional bool is_exclusive_control = 6;
  if (has_is_exclusive_control()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->is_exclusive_control(), target);
  }
  
  // optional .OstProto.TransmitMode transmit_mode = 7 [default = kSequentialTransmit];
  if (has_transmit_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->transmit_mode(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Port::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .OstProto.PortId port_id = 1;
    if (has_port_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->port_id());
    }
    
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string description = 3;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string notes = 4;
    if (has_notes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->notes());
    }
    
    // optional bool is_enabled = 5;
    if (has_is_enabled()) {
      total_size += 1 + 1;
    }
    
    // optional bool is_exclusive_control = 6;
    if (has_is_exclusive_control()) {
      total_size += 1 + 1;
    }
    
    // optional .OstProto.TransmitMode transmit_mode = 7 [default = kSequentialTransmit];
    if (has_transmit_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->transmit_mode());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Port::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Port* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Port*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Port::MergeFrom(const Port& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port_id()) {
      mutable_port_id()->::OstProto::PortId::MergeFrom(from.port_id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_notes()) {
      set_notes(from.notes());
    }
    if (from.has_is_enabled()) {
      set_is_enabled(from.is_enabled());
    }
    if (from.has_is_exclusive_control()) {
      set_is_exclusive_control(from.is_exclusive_control());
    }
    if (from.has_transmit_mode()) {
      set_transmit_mode(from.transmit_mode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Port::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Port::CopyFrom(const Port& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Port::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_port_id()) {
    if (!this->port_id().IsInitialized()) return false;
  }
  return true;
}

void Port::Swap(Port* other) {
  if (other != this) {
    std::swap(port_id_, other->port_id_);
    std::swap(name_, other->name_);
    std::swap(description_, other->description_);
    std::swap(notes_, other->notes_);
    std::swap(is_enabled_, other->is_enabled_);
    std::swap(is_exclusive_control_, other->is_exclusive_control_);
    std::swap(transmit_mode_, other->transmit_mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Port::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Port_descriptor_;
  metadata.reflection = Port_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PortConfigList::kPortFieldNumber;
#endif  // !_MSC_VER

PortConfigList::PortConfigList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PortConfigList::InitAsDefaultInstance() {
}

PortConfigList::PortConfigList(const PortConfigList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PortConfigList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PortConfigList::~PortConfigList() {
  SharedDtor();
}

void PortConfigList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PortConfigList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PortConfigList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PortConfigList_descriptor_;
}

const PortConfigList& PortConfigList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

PortConfigList* PortConfigList::default_instance_ = NULL;

PortConfigList* PortConfigList::New() const {
  return new PortConfigList;
}

void PortConfigList::Clear() {
  port_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PortConfigList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .OstProto.Port port = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_port:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_port()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_port;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PortConfigList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .OstProto.Port port = 1;
  for (int i = 0; i < this->port_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->port(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PortConfigList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .OstProto.Port port = 1;
  for (int i = 0; i < this->port_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->port(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PortConfigList::ByteSize() const {
  int total_size = 0;
  
  // repeated .OstProto.Port port = 1;
  total_size += 1 * this->port_size();
  for (int i = 0; i < this->port_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->port(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PortConfigList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PortConfigList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PortConfigList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PortConfigList::MergeFrom(const PortConfigList& from) {
  GOOGLE_CHECK_NE(&from, this);
  port_.MergeFrom(from.port_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PortConfigList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PortConfigList::CopyFrom(const PortConfigList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortConfigList::IsInitialized() const {
  
  for (int i = 0; i < port_size(); i++) {
    if (!this->port(i).IsInitialized()) return false;
  }
  return true;
}

void PortConfigList::Swap(PortConfigList* other) {
  if (other != this) {
    port_.Swap(&other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PortConfigList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PortConfigList_descriptor_;
  metadata.reflection = PortConfigList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StreamConfigList::kPortIdFieldNumber;
const int StreamConfigList::kStreamFieldNumber;
#endif  // !_MSC_VER

StreamConfigList::StreamConfigList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StreamConfigList::InitAsDefaultInstance() {
  port_id_ = const_cast< ::OstProto::PortId*>(&::OstProto::PortId::default_instance());
}

StreamConfigList::StreamConfigList(const StreamConfigList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StreamConfigList::SharedCtor() {
  _cached_size_ = 0;
  port_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StreamConfigList::~StreamConfigList() {
  SharedDtor();
}

void StreamConfigList::SharedDtor() {
  if (this != default_instance_) {
    delete port_id_;
  }
}

void StreamConfigList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StreamConfigList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamConfigList_descriptor_;
}

const StreamConfigList& StreamConfigList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

StreamConfigList* StreamConfigList::default_instance_ = NULL;

StreamConfigList* StreamConfigList::New() const {
  return new StreamConfigList;
}

void StreamConfigList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_port_id()) {
      if (port_id_ != NULL) port_id_->::OstProto::PortId::Clear();
    }
  }
  stream_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StreamConfigList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .OstProto.PortId port_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_port_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_stream;
        break;
      }
      
      // repeated .OstProto.Stream stream = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_stream:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_stream()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_stream;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StreamConfigList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .OstProto.PortId port_id = 1;
  if (has_port_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->port_id(), output);
  }
  
  // repeated .OstProto.Stream stream = 2;
  for (int i = 0; i < this->stream_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->stream(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StreamConfigList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .OstProto.PortId port_id = 1;
  if (has_port_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->port_id(), target);
  }
  
  // repeated .OstProto.Stream stream = 2;
  for (int i = 0; i < this->stream_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->stream(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StreamConfigList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .OstProto.PortId port_id = 1;
    if (has_port_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->port_id());
    }
    
  }
  // repeated .OstProto.Stream stream = 2;
  total_size += 1 * this->stream_size();
  for (int i = 0; i < this->stream_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->stream(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StreamConfigList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StreamConfigList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StreamConfigList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StreamConfigList::MergeFrom(const StreamConfigList& from) {
  GOOGLE_CHECK_NE(&from, this);
  stream_.MergeFrom(from.stream_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port_id()) {
      mutable_port_id()->::OstProto::PortId::MergeFrom(from.port_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StreamConfigList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StreamConfigList::CopyFrom(const StreamConfigList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamConfigList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_port_id()) {
    if (!this->port_id().IsInitialized()) return false;
  }
  for (int i = 0; i < stream_size(); i++) {
    if (!this->stream(i).IsInitialized()) return false;
  }
  return true;
}

void StreamConfigList::Swap(StreamConfigList* other) {
  if (other != this) {
    std::swap(port_id_, other->port_id_);
    stream_.Swap(&other->stream_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StreamConfigList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StreamConfigList_descriptor_;
  metadata.reflection = StreamConfigList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CaptureBuffer::CaptureBuffer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CaptureBuffer::InitAsDefaultInstance() {
}

CaptureBuffer::CaptureBuffer(const CaptureBuffer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CaptureBuffer::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CaptureBuffer::~CaptureBuffer() {
  SharedDtor();
}

void CaptureBuffer::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CaptureBuffer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CaptureBuffer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CaptureBuffer_descriptor_;
}

const CaptureBuffer& CaptureBuffer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

CaptureBuffer* CaptureBuffer::default_instance_ = NULL;

CaptureBuffer* CaptureBuffer::New() const {
  return new CaptureBuffer;
}

void CaptureBuffer::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CaptureBuffer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void CaptureBuffer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CaptureBuffer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CaptureBuffer::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CaptureBuffer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CaptureBuffer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CaptureBuffer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CaptureBuffer::MergeFrom(const CaptureBuffer& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CaptureBuffer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CaptureBuffer::CopyFrom(const CaptureBuffer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaptureBuffer::IsInitialized() const {
  
  return true;
}

void CaptureBuffer::Swap(CaptureBuffer* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CaptureBuffer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CaptureBuffer_descriptor_;
  metadata.reflection = CaptureBuffer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CaptureBufferList::kListFieldNumber;
#endif  // !_MSC_VER

CaptureBufferList::CaptureBufferList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CaptureBufferList::InitAsDefaultInstance() {
}

CaptureBufferList::CaptureBufferList(const CaptureBufferList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CaptureBufferList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CaptureBufferList::~CaptureBufferList() {
  SharedDtor();
}

void CaptureBufferList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CaptureBufferList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CaptureBufferList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CaptureBufferList_descriptor_;
}

const CaptureBufferList& CaptureBufferList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

CaptureBufferList* CaptureBufferList::default_instance_ = NULL;

CaptureBufferList* CaptureBufferList::New() const {
  return new CaptureBufferList;
}

void CaptureBufferList::Clear() {
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CaptureBufferList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .OstProto.CaptureBuffer list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CaptureBufferList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .OstProto.CaptureBuffer list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CaptureBufferList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .OstProto.CaptureBuffer list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CaptureBufferList::ByteSize() const {
  int total_size = 0;
  
  // repeated .OstProto.CaptureBuffer list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CaptureBufferList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CaptureBufferList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CaptureBufferList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CaptureBufferList::MergeFrom(const CaptureBufferList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CaptureBufferList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CaptureBufferList::CopyFrom(const CaptureBufferList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaptureBufferList::IsInitialized() const {
  
  return true;
}

void CaptureBufferList::Swap(CaptureBufferList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CaptureBufferList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CaptureBufferList_descriptor_;
  metadata.reflection = CaptureBufferList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PortState::kLinkStateFieldNumber;
const int PortState::kIsTransmitOnFieldNumber;
const int PortState::kIsCaptureOnFieldNumber;
#endif  // !_MSC_VER

PortState::PortState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PortState::InitAsDefaultInstance() {
}

PortState::PortState(const PortState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PortState::SharedCtor() {
  _cached_size_ = 0;
  link_state_ = 0;
  is_transmit_on_ = false;
  is_capture_on_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PortState::~PortState() {
  SharedDtor();
}

void PortState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PortState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PortState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PortState_descriptor_;
}

const PortState& PortState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

PortState* PortState::default_instance_ = NULL;

PortState* PortState::New() const {
  return new PortState;
}

void PortState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    link_state_ = 0;
    is_transmit_on_ = false;
    is_capture_on_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PortState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .OstProto.LinkState link_state = 1 [default = LinkStateUnknown];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (OstProto::LinkState_IsValid(value)) {
            set_link_state(static_cast< OstProto::LinkState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_transmit_on;
        break;
      }
      
      // optional bool is_transmit_on = 2 [default = false];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_transmit_on:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_transmit_on_)));
          set_has_is_transmit_on();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_is_capture_on;
        break;
      }
      
      // optional bool is_capture_on = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_capture_on:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_capture_on_)));
          set_has_is_capture_on();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PortState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .OstProto.LinkState link_state = 1 [default = LinkStateUnknown];
  if (has_link_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->link_state(), output);
  }
  
  // optional bool is_transmit_on = 2 [default = false];
  if (has_is_transmit_on()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_transmit_on(), output);
  }
  
  // optional bool is_capture_on = 3 [default = false];
  if (has_is_capture_on()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_capture_on(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PortState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .OstProto.LinkState link_state = 1 [default = LinkStateUnknown];
  if (has_link_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->link_state(), target);
  }
  
  // optional bool is_transmit_on = 2 [default = false];
  if (has_is_transmit_on()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->is_transmit_on(), target);
  }
  
  // optional bool is_capture_on = 3 [default = false];
  if (has_is_capture_on()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->is_capture_on(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PortState::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .OstProto.LinkState link_state = 1 [default = LinkStateUnknown];
    if (has_link_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->link_state());
    }
    
    // optional bool is_transmit_on = 2 [default = false];
    if (has_is_transmit_on()) {
      total_size += 1 + 1;
    }
    
    // optional bool is_capture_on = 3 [default = false];
    if (has_is_capture_on()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PortState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PortState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PortState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PortState::MergeFrom(const PortState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_link_state()) {
      set_link_state(from.link_state());
    }
    if (from.has_is_transmit_on()) {
      set_is_transmit_on(from.is_transmit_on());
    }
    if (from.has_is_capture_on()) {
      set_is_capture_on(from.is_capture_on());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PortState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PortState::CopyFrom(const PortState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortState::IsInitialized() const {
  
  return true;
}

void PortState::Swap(PortState* other) {
  if (other != this) {
    std::swap(link_state_, other->link_state_);
    std::swap(is_transmit_on_, other->is_transmit_on_);
    std::swap(is_capture_on_, other->is_capture_on_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PortState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PortState_descriptor_;
  metadata.reflection = PortState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PortStats::kPortIdFieldNumber;
const int PortStats::kStateFieldNumber;
const int PortStats::kRxPktsFieldNumber;
const int PortStats::kRxBytesFieldNumber;
const int PortStats::kRxPktsNicFieldNumber;
const int PortStats::kRxBytesNicFieldNumber;
const int PortStats::kRxPpsFieldNumber;
const int PortStats::kRxBpsFieldNumber;
const int PortStats::kTxPktsFieldNumber;
const int PortStats::kTxBytesFieldNumber;
const int PortStats::kTxPktsNicFieldNumber;
const int PortStats::kTxBytesNicFieldNumber;
const int PortStats::kTxPpsFieldNumber;
const int PortStats::kTxBpsFieldNumber;
const int PortStats::kRxDropsFieldNumber;
const int PortStats::kRxErrorsFieldNumber;
const int PortStats::kRxFifoErrorsFieldNumber;
const int PortStats::kRxFrameErrorsFieldNumber;
#endif  // !_MSC_VER

PortStats::PortStats()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PortStats::InitAsDefaultInstance() {
  port_id_ = const_cast< ::OstProto::PortId*>(&::OstProto::PortId::default_instance());
  state_ = const_cast< ::OstProto::PortState*>(&::OstProto::PortState::default_instance());
}

PortStats::PortStats(const PortStats& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PortStats::SharedCtor() {
  _cached_size_ = 0;
  port_id_ = NULL;
  state_ = NULL;
  rx_pkts_ = GOOGLE_ULONGLONG(0);
  rx_bytes_ = GOOGLE_ULONGLONG(0);
  rx_pkts_nic_ = GOOGLE_ULONGLONG(0);
  rx_bytes_nic_ = GOOGLE_ULONGLONG(0);
  rx_pps_ = GOOGLE_ULONGLONG(0);
  rx_bps_ = GOOGLE_ULONGLONG(0);
  tx_pkts_ = GOOGLE_ULONGLONG(0);
  tx_bytes_ = GOOGLE_ULONGLONG(0);
  tx_pkts_nic_ = GOOGLE_ULONGLONG(0);
  tx_bytes_nic_ = GOOGLE_ULONGLONG(0);
  tx_pps_ = GOOGLE_ULONGLONG(0);
  tx_bps_ = GOOGLE_ULONGLONG(0);
  rx_drops_ = GOOGLE_ULONGLONG(0);
  rx_errors_ = GOOGLE_ULONGLONG(0);
  rx_fifo_errors_ = GOOGLE_ULONGLONG(0);
  rx_frame_errors_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PortStats::~PortStats() {
  SharedDtor();
}

void PortStats::SharedDtor() {
  if (this != default_instance_) {
    delete port_id_;
    delete state_;
  }
}

void PortStats::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PortStats::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PortStats_descriptor_;
}

const PortStats& PortStats::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

PortStats* PortStats::default_instance_ = NULL;

PortStats* PortStats::New() const {
  return new PortStats;
}

void PortStats::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_port_id()) {
      if (port_id_ != NULL) port_id_->::OstProto::PortId::Clear();
    }
    if (has_state()) {
      if (state_ != NULL) state_->::OstProto::PortState::Clear();
    }
    rx_pkts_ = GOOGLE_ULONGLONG(0);
    rx_bytes_ = GOOGLE_ULONGLONG(0);
    rx_pkts_nic_ = GOOGLE_ULONGLONG(0);
    rx_bytes_nic_ = GOOGLE_ULONGLONG(0);
    rx_pps_ = GOOGLE_ULONGLONG(0);
    rx_bps_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    tx_pkts_ = GOOGLE_ULONGLONG(0);
    tx_bytes_ = GOOGLE_ULONGLONG(0);
    tx_pkts_nic_ = GOOGLE_ULONGLONG(0);
    tx_bytes_nic_ = GOOGLE_ULONGLONG(0);
    tx_pps_ = GOOGLE_ULONGLONG(0);
    tx_bps_ = GOOGLE_ULONGLONG(0);
    rx_drops_ = GOOGLE_ULONGLONG(0);
    rx_errors_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    rx_fifo_errors_ = GOOGLE_ULONGLONG(0);
    rx_frame_errors_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PortStats::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .OstProto.PortId port_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_port_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_state;
        break;
      }
      
      // optional .OstProto.PortState state = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_state()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_rx_pkts;
        break;
      }
      
      // optional uint64 rx_pkts = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rx_pkts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &rx_pkts_)));
          set_has_rx_pkts();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_rx_bytes;
        break;
      }
      
      // optional uint64 rx_bytes = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rx_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &rx_bytes_)));
          set_has_rx_bytes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_rx_pkts_nic;
        break;
      }
      
      // optional uint64 rx_pkts_nic = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rx_pkts_nic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &rx_pkts_nic_)));
          set_has_rx_pkts_nic();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_rx_bytes_nic;
        break;
      }
      
      // optional uint64 rx_bytes_nic = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rx_bytes_nic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &rx_bytes_nic_)));
          set_has_rx_bytes_nic();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_rx_pps;
        break;
      }
      
      // optional uint64 rx_pps = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rx_pps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &rx_pps_)));
          set_has_rx_pps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_rx_bps;
        break;
      }
      
      // optional uint64 rx_bps = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rx_bps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &rx_bps_)));
          set_has_rx_bps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(168)) goto parse_tx_pkts;
        break;
      }
      
      // optional uint64 tx_pkts = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tx_pkts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tx_pkts_)));
          set_has_tx_pkts();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(176)) goto parse_tx_bytes;
        break;
      }
      
      // optional uint64 tx_bytes = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tx_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tx_bytes_)));
          set_has_tx_bytes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(184)) goto parse_tx_pkts_nic;
        break;
      }
      
      // optional uint64 tx_pkts_nic = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tx_pkts_nic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tx_pkts_nic_)));
          set_has_tx_pkts_nic();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(192)) goto parse_tx_bytes_nic;
        break;
      }
      
      // optional uint64 tx_bytes_nic = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tx_bytes_nic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tx_bytes_nic_)));
          set_has_tx_bytes_nic();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(200)) goto parse_tx_pps;
        break;
      }
      
      // optional uint64 tx_pps = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tx_pps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tx_pps_)));
          set_has_tx_pps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(208)) goto parse_tx_bps;
        break;
      }
      
      // optional uint64 tx_bps = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tx_bps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tx_bps_)));
          set_has_tx_bps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(800)) goto parse_rx_drops;
        break;
      }
      
      // optional uint64 rx_drops = 100;
      case 100: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rx_drops:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &rx_drops_)));
          set_has_rx_drops();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(808)) goto parse_rx_errors;
        break;
      }
      
      // optional uint64 rx_errors = 101;
      case 101: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rx_errors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &rx_errors_)));
          set_has_rx_errors();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(816)) goto parse_rx_fifo_errors;
        break;
      }
      
      // optional uint64 rx_fifo_errors = 102;
      case 102: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rx_fifo_errors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &rx_fifo_errors_)));
          set_has_rx_fifo_errors();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(824)) goto parse_rx_frame_errors;
        break;
      }
      
      // optional uint64 rx_frame_errors = 103;
      case 103: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rx_frame_errors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &rx_frame_errors_)));
          set_has_rx_frame_errors();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PortStats::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .OstProto.PortId port_id = 1;
  if (has_port_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->port_id(), output);
  }
  
  // optional .OstProto.PortState state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->state(), output);
  }
  
  // optional uint64 rx_pkts = 11;
  if (has_rx_pkts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->rx_pkts(), output);
  }
  
  // optional uint64 rx_bytes = 12;
  if (has_rx_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(12, this->rx_bytes(), output);
  }
  
  // optional uint64 rx_pkts_nic = 13;
  if (has_rx_pkts_nic()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(13, this->rx_pkts_nic(), output);
  }
  
  // optional uint64 rx_bytes_nic = 14;
  if (has_rx_bytes_nic()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(14, this->rx_bytes_nic(), output);
  }
  
  // optional uint64 rx_pps = 15;
  if (has_rx_pps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->rx_pps(), output);
  }
  
  // optional uint64 rx_bps = 16;
  if (has_rx_bps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(16, this->rx_bps(), output);
  }
  
  // optional uint64 tx_pkts = 21;
  if (has_tx_pkts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(21, this->tx_pkts(), output);
  }
  
  // optional uint64 tx_bytes = 22;
  if (has_tx_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(22, this->tx_bytes(), output);
  }
  
  // optional uint64 tx_pkts_nic = 23;
  if (has_tx_pkts_nic()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(23, this->tx_pkts_nic(), output);
  }
  
  // optional uint64 tx_bytes_nic = 24;
  if (has_tx_bytes_nic()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(24, this->tx_bytes_nic(), output);
  }
  
  // optional uint64 tx_pps = 25;
  if (has_tx_pps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(25, this->tx_pps(), output);
  }
  
  // optional uint64 tx_bps = 26;
  if (has_tx_bps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(26, this->tx_bps(), output);
  }
  
  // optional uint64 rx_drops = 100;
  if (has_rx_drops()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(100, this->rx_drops(), output);
  }
  
  // optional uint64 rx_errors = 101;
  if (has_rx_errors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(101, this->rx_errors(), output);
  }
  
  // optional uint64 rx_fifo_errors = 102;
  if (has_rx_fifo_errors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(102, this->rx_fifo_errors(), output);
  }
  
  // optional uint64 rx_frame_errors = 103;
  if (has_rx_frame_errors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(103, this->rx_frame_errors(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PortStats::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .OstProto.PortId port_id = 1;
  if (has_port_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->port_id(), target);
  }
  
  // optional .OstProto.PortState state = 2;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->state(), target);
  }
  
  // optional uint64 rx_pkts = 11;
  if (has_rx_pkts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->rx_pkts(), target);
  }
  
  // optional uint64 rx_bytes = 12;
  if (has_rx_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(12, this->rx_bytes(), target);
  }
  
  // optional uint64 rx_pkts_nic = 13;
  if (has_rx_pkts_nic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(13, this->rx_pkts_nic(), target);
  }
  
  // optional uint64 rx_bytes_nic = 14;
  if (has_rx_bytes_nic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(14, this->rx_bytes_nic(), target);
  }
  
  // optional uint64 rx_pps = 15;
  if (has_rx_pps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(15, this->rx_pps(), target);
  }
  
  // optional uint64 rx_bps = 16;
  if (has_rx_bps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(16, this->rx_bps(), target);
  }
  
  // optional uint64 tx_pkts = 21;
  if (has_tx_pkts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(21, this->tx_pkts(), target);
  }
  
  // optional uint64 tx_bytes = 22;
  if (has_tx_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(22, this->tx_bytes(), target);
  }
  
  // optional uint64 tx_pkts_nic = 23;
  if (has_tx_pkts_nic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(23, this->tx_pkts_nic(), target);
  }
  
  // optional uint64 tx_bytes_nic = 24;
  if (has_tx_bytes_nic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(24, this->tx_bytes_nic(), target);
  }
  
  // optional uint64 tx_pps = 25;
  if (has_tx_pps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(25, this->tx_pps(), target);
  }
  
  // optional uint64 tx_bps = 26;
  if (has_tx_bps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(26, this->tx_bps(), target);
  }
  
  // optional uint64 rx_drops = 100;
  if (has_rx_drops()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(100, this->rx_drops(), target);
  }
  
  // optional uint64 rx_errors = 101;
  if (has_rx_errors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(101, this->rx_errors(), target);
  }
  
  // optional uint64 rx_fifo_errors = 102;
  if (has_rx_fifo_errors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(102, this->rx_fifo_errors(), target);
  }
  
  // optional uint64 rx_frame_errors = 103;
  if (has_rx_frame_errors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(103, this->rx_frame_errors(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PortStats::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .OstProto.PortId port_id = 1;
    if (has_port_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->port_id());
    }
    
    // optional .OstProto.PortState state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->state());
    }
    
    // optional uint64 rx_pkts = 11;
    if (has_rx_pkts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->rx_pkts());
    }
    
    // optional uint64 rx_bytes = 12;
    if (has_rx_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->rx_bytes());
    }
    
    // optional uint64 rx_pkts_nic = 13;
    if (has_rx_pkts_nic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->rx_pkts_nic());
    }
    
    // optional uint64 rx_bytes_nic = 14;
    if (has_rx_bytes_nic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->rx_bytes_nic());
    }
    
    // optional uint64 rx_pps = 15;
    if (has_rx_pps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->rx_pps());
    }
    
    // optional uint64 rx_bps = 16;
    if (has_rx_bps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->rx_bps());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint64 tx_pkts = 21;
    if (has_tx_pkts()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tx_pkts());
    }
    
    // optional uint64 tx_bytes = 22;
    if (has_tx_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tx_bytes());
    }
    
    // optional uint64 tx_pkts_nic = 23;
    if (has_tx_pkts_nic()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tx_pkts_nic());
    }
    
    // optional uint64 tx_bytes_nic = 24;
    if (has_tx_bytes_nic()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tx_bytes_nic());
    }
    
    // optional uint64 tx_pps = 25;
    if (has_tx_pps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tx_pps());
    }
    
    // optional uint64 tx_bps = 26;
    if (has_tx_bps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tx_bps());
    }
    
    // optional uint64 rx_drops = 100;
    if (has_rx_drops()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->rx_drops());
    }
    
    // optional uint64 rx_errors = 101;
    if (has_rx_errors()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->rx_errors());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional uint64 rx_fifo_errors = 102;
    if (has_rx_fifo_errors()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->rx_fifo_errors());
    }
    
    // optional uint64 rx_frame_errors = 103;
    if (has_rx_frame_errors()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->rx_frame_errors());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PortStats::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PortStats* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PortStats*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PortStats::MergeFrom(const PortStats& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port_id()) {
      mutable_port_id()->::OstProto::PortId::MergeFrom(from.port_id());
    }
    if (from.has_state()) {
      mutable_state()->::OstProto::PortState::MergeFrom(from.state());
    }
    if (from.has_rx_pkts()) {
      set_rx_pkts(from.rx_pkts());
    }
    if (from.has_rx_bytes()) {
      set_rx_bytes(from.rx_bytes());
    }
    if (from.has_rx_pkts_nic()) {
      set_rx_pkts_nic(from.rx_pkts_nic());
    }
    if (from.has_rx_bytes_nic()) {
      set_rx_bytes_nic(from.rx_bytes_nic());
    }
    if (from.has_rx_pps()) {
      set_rx_pps(from.rx_pps());
    }
    if (from.has_rx_bps()) {
      set_rx_bps(from.rx_bps());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_tx_pkts()) {
      set_tx_pkts(from.tx_pkts());
    }
    if (from.has_tx_bytes()) {
      set_tx_bytes(from.tx_bytes());
    }
    if (from.has_tx_pkts_nic()) {
      set_tx_pkts_nic(from.tx_pkts_nic());
    }
    if (from.has_tx_bytes_nic()) {
      set_tx_bytes_nic(from.tx_bytes_nic());
    }
    if (from.has_tx_pps()) {
      set_tx_pps(from.tx_pps());
    }
    if (from.has_tx_bps()) {
      set_tx_bps(from.tx_bps());
    }
    if (from.has_rx_drops()) {
      set_rx_drops(from.rx_drops());
    }
    if (from.has_rx_errors()) {
      set_rx_errors(from.rx_errors());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_rx_fifo_errors()) {
      set_rx_fifo_errors(from.rx_fifo_errors());
    }
    if (from.has_rx_frame_errors()) {
      set_rx_frame_errors(from.rx_frame_errors());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PortStats::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PortStats::CopyFrom(const PortStats& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortStats::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_port_id()) {
    if (!this->port_id().IsInitialized()) return false;
  }
  return true;
}

void PortStats::Swap(PortStats* other) {
  if (other != this) {
    std::swap(port_id_, other->port_id_);
    std::swap(state_, other->state_);
    std::swap(rx_pkts_, other->rx_pkts_);
    std::swap(rx_bytes_, other->rx_bytes_);
    std::swap(rx_pkts_nic_, other->rx_pkts_nic_);
    std::swap(rx_bytes_nic_, other->rx_bytes_nic_);
    std::swap(rx_pps_, other->rx_pps_);
    std::swap(rx_bps_, other->rx_bps_);
    std::swap(tx_pkts_, other->tx_pkts_);
    std::swap(tx_bytes_, other->tx_bytes_);
    std::swap(tx_pkts_nic_, other->tx_pkts_nic_);
    std::swap(tx_bytes_nic_, other->tx_bytes_nic_);
    std::swap(tx_pps_, other->tx_pps_);
    std::swap(tx_bps_, other->tx_bps_);
    std::swap(rx_drops_, other->rx_drops_);
    std::swap(rx_errors_, other->rx_errors_);
    std::swap(rx_fifo_errors_, other->rx_fifo_errors_);
    std::swap(rx_frame_errors_, other->rx_frame_errors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PortStats::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PortStats_descriptor_;
  metadata.reflection = PortStats_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PortStatsList::kPortStatsFieldNumber;
#endif  // !_MSC_VER

PortStatsList::PortStatsList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PortStatsList::InitAsDefaultInstance() {
}

PortStatsList::PortStatsList(const PortStatsList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PortStatsList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PortStatsList::~PortStatsList() {
  SharedDtor();
}

void PortStatsList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PortStatsList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PortStatsList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PortStatsList_descriptor_;
}

const PortStatsList& PortStatsList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_protocol_2eproto();  return *default_instance_;
}

PortStatsList* PortStatsList::default_instance_ = NULL;

PortStatsList* PortStatsList::New() const {
  return new PortStatsList;
}

void PortStatsList::Clear() {
  port_stats_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PortStatsList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .OstProto.PortStats port_stats = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_port_stats:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_port_stats()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_port_stats;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PortStatsList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .OstProto.PortStats port_stats = 1;
  for (int i = 0; i < this->port_stats_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->port_stats(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PortStatsList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .OstProto.PortStats port_stats = 1;
  for (int i = 0; i < this->port_stats_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->port_stats(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PortStatsList::ByteSize() const {
  int total_size = 0;
  
  // repeated .OstProto.PortStats port_stats = 1;
  total_size += 1 * this->port_stats_size();
  for (int i = 0; i < this->port_stats_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->port_stats(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PortStatsList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PortStatsList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PortStatsList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PortStatsList::MergeFrom(const PortStatsList& from) {
  GOOGLE_CHECK_NE(&from, this);
  port_stats_.MergeFrom(from.port_stats_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PortStatsList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PortStatsList::CopyFrom(const PortStatsList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortStatsList::IsInitialized() const {
  
  for (int i = 0; i < port_stats_size(); i++) {
    if (!this->port_stats(i).IsInitialized()) return false;
  }
  return true;
}

void PortStatsList::Swap(PortStatsList* other) {
  if (other != this) {
    port_stats_.Swap(&other->port_stats_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PortStatsList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PortStatsList_descriptor_;
  metadata.reflection = PortStatsList_reflection_;
  return metadata;
}


// ===================================================================

OstService::~OstService() {}

const ::google::protobuf::ServiceDescriptor* OstService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OstService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* OstService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return OstService_descriptor_;
}

void OstService::getPortIdList(::google::protobuf::RpcController* controller,
                         const ::OstProto::Void*,
                         ::OstProto::PortIdList*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method getPortIdList() not implemented.");
  done->Run();
}

void OstService::getPortConfig(::google::protobuf::RpcController* controller,
                         const ::OstProto::PortIdList*,
                         ::OstProto::PortConfigList*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method getPortConfig() not implemented.");
  done->Run();
}

void OstService::modifyPort(::google::protobuf::RpcController* controller,
                         const ::OstProto::PortConfigList*,
                         ::OstProto::Ack*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method modifyPort() not implemented.");
  done->Run();
}

void OstService::getStreamIdList(::google::protobuf::RpcController* controller,
                         const ::OstProto::PortId*,
                         ::OstProto::StreamIdList*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method getStreamIdList() not implemented.");
  done->Run();
}

void OstService::getStreamConfig(::google::protobuf::RpcController* controller,
                         const ::OstProto::StreamIdList*,
                         ::OstProto::StreamConfigList*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method getStreamConfig() not implemented.");
  done->Run();
}

void OstService::addStream(::google::protobuf::RpcController* controller,
                         const ::OstProto::StreamIdList*,
                         ::OstProto::Ack*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method addStream() not implemented.");
  done->Run();
}

void OstService::deleteStream(::google::protobuf::RpcController* controller,
                         const ::OstProto::StreamIdList*,
                         ::OstProto::Ack*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method deleteStream() not implemented.");
  done->Run();
}

void OstService::modifyStream(::google::protobuf::RpcController* controller,
                         const ::OstProto::StreamConfigList*,
                         ::OstProto::Ack*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method modifyStream() not implemented.");
  done->Run();
}

void OstService::startTransmit(::google::protobuf::RpcController* controller,
                         const ::OstProto::PortIdList*,
                         ::OstProto::Ack*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method startTransmit() not implemented.");
  done->Run();
}

void OstService::stopTransmit(::google::protobuf::RpcController* controller,
                         const ::OstProto::PortIdList*,
                         ::OstProto::Ack*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method stopTransmit() not implemented.");
  done->Run();
}

void OstService::startCapture(::google::protobuf::RpcController* controller,
                         const ::OstProto::PortIdList*,
                         ::OstProto::Ack*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method startCapture() not implemented.");
  done->Run();
}

void OstService::stopCapture(::google::protobuf::RpcController* controller,
                         const ::OstProto::PortIdList*,
                         ::OstProto::Ack*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method stopCapture() not implemented.");
  done->Run();
}

void OstService::getCaptureBuffer(::google::protobuf::RpcController* controller,
                         const ::OstProto::PortId*,
                         ::OstProto::CaptureBuffer*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method getCaptureBuffer() not implemented.");
  done->Run();
}

void OstService::getStats(::google::protobuf::RpcController* controller,
                         const ::OstProto::PortIdList*,
                         ::OstProto::PortStatsList*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method getStats() not implemented.");
  done->Run();
}

void OstService::clearStats(::google::protobuf::RpcController* controller,
                         const ::OstProto::PortIdList*,
                         ::OstProto::Ack*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method clearStats() not implemented.");
  done->Run();
}

void OstService::checkVersion(::google::protobuf::RpcController* controller,
                         const ::OstProto::VersionInfo*,
                         ::OstProto::VersionCompatibility*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method checkVersion() not implemented.");
  done->Run();
}

void OstService::CallMethod(const ::google::protobuf::MethodDescriptor* method,
                             ::google::protobuf::RpcController* controller,
                             const ::google::protobuf::Message* request,
                             ::google::protobuf::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), OstService_descriptor_);
  switch(method->index()) {
    case 0:
      getPortIdList(controller,
             ::google::protobuf::down_cast<const ::OstProto::Void*>(request),
             ::google::protobuf::down_cast< ::OstProto::PortIdList*>(response),
             done);
      break;
    case 1:
      getPortConfig(controller,
             ::google::protobuf::down_cast<const ::OstProto::PortIdList*>(request),
             ::google::protobuf::down_cast< ::OstProto::PortConfigList*>(response),
             done);
      break;
    case 2:
      modifyPort(controller,
             ::google::protobuf::down_cast<const ::OstProto::PortConfigList*>(request),
             ::google::protobuf::down_cast< ::OstProto::Ack*>(response),
             done);
      break;
    case 3:
      getStreamIdList(controller,
             ::google::protobuf::down_cast<const ::OstProto::PortId*>(request),
             ::google::protobuf::down_cast< ::OstProto::StreamIdList*>(response),
             done);
      break;
    case 4:
      getStreamConfig(controller,
             ::google::protobuf::down_cast<const ::OstProto::StreamIdList*>(request),
             ::google::protobuf::down_cast< ::OstProto::StreamConfigList*>(response),
             done);
      break;
    case 5:
      addStream(controller,
             ::google::protobuf::down_cast<const ::OstProto::StreamIdList*>(request),
             ::google::protobuf::down_cast< ::OstProto::Ack*>(response),
             done);
      break;
    case 6:
      deleteStream(controller,
             ::google::protobuf::down_cast<const ::OstProto::StreamIdList*>(request),
             ::google::protobuf::down_cast< ::OstProto::Ack*>(response),
             done);
      break;
    case 7:
      modifyStream(controller,
             ::google::protobuf::down_cast<const ::OstProto::StreamConfigList*>(request),
             ::google::protobuf::down_cast< ::OstProto::Ack*>(response),
             done);
      break;
    case 8:
      startTransmit(controller,
             ::google::protobuf::down_cast<const ::OstProto::PortIdList*>(request),
             ::google::protobuf::down_cast< ::OstProto::Ack*>(response),
             done);
      break;
    case 9:
      stopTransmit(controller,
             ::google::protobuf::down_cast<const ::OstProto::PortIdList*>(request),
             ::google::protobuf::down_cast< ::OstProto::Ack*>(response),
             done);
      break;
    case 10:
      startCapture(controller,
             ::google::protobuf::down_cast<const ::OstProto::PortIdList*>(request),
             ::google::protobuf::down_cast< ::OstProto::Ack*>(response),
             done);
      break;
    case 11:
      stopCapture(controller,
             ::google::protobuf::down_cast<const ::OstProto::PortIdList*>(request),
             ::google::protobuf::down_cast< ::OstProto::Ack*>(response),
             done);
      break;
    case 12:
      getCaptureBuffer(controller,
             ::google::protobuf::down_cast<const ::OstProto::PortId*>(request),
             ::google::protobuf::down_cast< ::OstProto::CaptureBuffer*>(response),
             done);
      break;
    case 13:
      getStats(controller,
             ::google::protobuf::down_cast<const ::OstProto::PortIdList*>(request),
             ::google::protobuf::down_cast< ::OstProto::PortStatsList*>(response),
             done);
      break;
    case 14:
      clearStats(controller,
             ::google::protobuf::down_cast<const ::OstProto::PortIdList*>(request),
             ::google::protobuf::down_cast< ::OstProto::Ack*>(response),
             done);
      break;
    case 15:
      checkVersion(controller,
             ::google::protobuf::down_cast<const ::OstProto::VersionInfo*>(request),
             ::google::protobuf::down_cast< ::OstProto::VersionCompatibility*>(response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& OstService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::OstProto::Void::default_instance();
    case 1:
      return ::OstProto::PortIdList::default_instance();
    case 2:
      return ::OstProto::PortConfigList::default_instance();
    case 3:
      return ::OstProto::PortId::default_instance();
    case 4:
      return ::OstProto::StreamIdList::default_instance();
    case 5:
      return ::OstProto::StreamIdList::default_instance();
    case 6:
      return ::OstProto::StreamIdList::default_instance();
    case 7:
      return ::OstProto::StreamConfigList::default_instance();
    case 8:
      return ::OstProto::PortIdList::default_instance();
    case 9:
      return ::OstProto::PortIdList::default_instance();
    case 10:
      return ::OstProto::PortIdList::default_instance();
    case 11:
      return ::OstProto::PortIdList::default_instance();
    case 12:
      return ::OstProto::PortId::default_instance();
    case 13:
      return ::OstProto::PortIdList::default_instance();
    case 14:
      return ::OstProto::PortIdList::default_instance();
    case 15:
      return ::OstProto::VersionInfo::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& OstService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::OstProto::PortIdList::default_instance();
    case 1:
      return ::OstProto::PortConfigList::default_instance();
    case 2:
      return ::OstProto::Ack::default_instance();
    case 3:
      return ::OstProto::StreamIdList::default_instance();
    case 4:
      return ::OstProto::StreamConfigList::default_instance();
    case 5:
      return ::OstProto::Ack::default_instance();
    case 6:
      return ::OstProto::Ack::default_instance();
    case 7:
      return ::OstProto::Ack::default_instance();
    case 8:
      return ::OstProto::Ack::default_instance();
    case 9:
      return ::OstProto::Ack::default_instance();
    case 10:
      return ::OstProto::Ack::default_instance();
    case 11:
      return ::OstProto::Ack::default_instance();
    case 12:
      return ::OstProto::CaptureBuffer::default_instance();
    case 13:
      return ::OstProto::PortStatsList::default_instance();
    case 14:
      return ::OstProto::Ack::default_instance();
    case 15:
      return ::OstProto::VersionCompatibility::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

OstService_Stub::OstService_Stub(::google::protobuf::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
OstService_Stub::OstService_Stub(
    ::google::protobuf::RpcChannel* channel,
    ::google::protobuf::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::google::protobuf::Service::STUB_OWNS_CHANNEL) {}
OstService_Stub::~OstService_Stub() {
  if (owns_channel_) delete channel_;
}

void OstService_Stub::getPortIdList(::google::protobuf::RpcController* controller,
                              const ::OstProto::Void* request,
                              ::OstProto::PortIdList* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void OstService_Stub::getPortConfig(::google::protobuf::RpcController* controller,
                              const ::OstProto::PortIdList* request,
                              ::OstProto::PortConfigList* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void OstService_Stub::modifyPort(::google::protobuf::RpcController* controller,
                              const ::OstProto::PortConfigList* request,
                              ::OstProto::Ack* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void OstService_Stub::getStreamIdList(::google::protobuf::RpcController* controller,
                              const ::OstProto::PortId* request,
                              ::OstProto::StreamIdList* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void OstService_Stub::getStreamConfig(::google::protobuf::RpcController* controller,
                              const ::OstProto::StreamIdList* request,
                              ::OstProto::StreamConfigList* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void OstService_Stub::addStream(::google::protobuf::RpcController* controller,
                              const ::OstProto::StreamIdList* request,
                              ::OstProto::Ack* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}
void OstService_Stub::deleteStream(::google::protobuf::RpcController* controller,
                              const ::OstProto::StreamIdList* request,
                              ::OstProto::Ack* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(6),
                       controller, request, response, done);
}
void OstService_Stub::modifyStream(::google::protobuf::RpcController* controller,
                              const ::OstProto::StreamConfigList* request,
                              ::OstProto::Ack* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(7),
                       controller, request, response, done);
}
void OstService_Stub::startTransmit(::google::protobuf::RpcController* controller,
                              const ::OstProto::PortIdList* request,
                              ::OstProto::Ack* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(8),
                       controller, request, response, done);
}
void OstService_Stub::stopTransmit(::google::protobuf::RpcController* controller,
                              const ::OstProto::PortIdList* request,
                              ::OstProto::Ack* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(9),
                       controller, request, response, done);
}
void OstService_Stub::startCapture(::google::protobuf::RpcController* controller,
                              const ::OstProto::PortIdList* request,
                              ::OstProto::Ack* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(10),
                       controller, request, response, done);
}
void OstService_Stub::stopCapture(::google::protobuf::RpcController* controller,
                              const ::OstProto::PortIdList* request,
                              ::OstProto::Ack* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(11),
                       controller, request, response, done);
}
void OstService_Stub::getCaptureBuffer(::google::protobuf::RpcController* controller,
                              const ::OstProto::PortId* request,
                              ::OstProto::CaptureBuffer* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(12),
                       controller, request, response, done);
}
void OstService_Stub::getStats(::google::protobuf::RpcController* controller,
                              const ::OstProto::PortIdList* request,
                              ::OstProto::PortStatsList* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(13),
                       controller, request, response, done);
}
void OstService_Stub::clearStats(::google::protobuf::RpcController* controller,
                              const ::OstProto::PortIdList* request,
                              ::OstProto::Ack* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(14),
                       controller, request, response, done);
}
void OstService_Stub::checkVersion(::google::protobuf::RpcController* controller,
                              const ::OstProto::VersionInfo* request,
                              ::OstProto::VersionCompatibility* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(15),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace OstProto

// @@protoc_insertion_point(global_scope)
