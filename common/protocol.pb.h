// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_protocol_2eproto__INCLUDED
#define PROTOBUF_protocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/service.h>
// @@protoc_insertion_point(includes)

namespace OstProto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protocol_2eproto();
void protobuf_AssignDesc_protocol_2eproto();
void protobuf_ShutdownFile_protocol_2eproto();

class VersionInfo;
class VersionCompatibility;
class StreamId;
class StreamCore;
class StreamControl;
class ProtocolId;
class Protocol;
class Stream;
class Void;
class Ack;
class PortId;
class PortIdList;
class StreamIdList;
class Port;
class PortConfigList;
class StreamConfigList;
class CaptureBuffer;
class CaptureBufferList;
class PortState;
class PortStats;
class PortStatsList;

enum VersionCompatibility_Compatibility {
  VersionCompatibility_Compatibility_kIncompatible = 0,
  VersionCompatibility_Compatibility_kCompatible = 1
};
bool VersionCompatibility_Compatibility_IsValid(int value);
const VersionCompatibility_Compatibility VersionCompatibility_Compatibility_Compatibility_MIN = VersionCompatibility_Compatibility_kIncompatible;
const VersionCompatibility_Compatibility VersionCompatibility_Compatibility_Compatibility_MAX = VersionCompatibility_Compatibility_kCompatible;
const int VersionCompatibility_Compatibility_Compatibility_ARRAYSIZE = VersionCompatibility_Compatibility_Compatibility_MAX + 1;

const ::google::protobuf::EnumDescriptor* VersionCompatibility_Compatibility_descriptor();
inline const ::std::string& VersionCompatibility_Compatibility_Name(VersionCompatibility_Compatibility value) {
  return ::google::protobuf::internal::NameOfEnum(
    VersionCompatibility_Compatibility_descriptor(), value);
}
inline bool VersionCompatibility_Compatibility_Parse(
    const ::std::string& name, VersionCompatibility_Compatibility* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VersionCompatibility_Compatibility>(
    VersionCompatibility_Compatibility_descriptor(), name, value);
}
enum StreamCore_FrameLengthMode {
  StreamCore_FrameLengthMode_e_fl_fixed = 0,
  StreamCore_FrameLengthMode_e_fl_inc = 1,
  StreamCore_FrameLengthMode_e_fl_dec = 2,
  StreamCore_FrameLengthMode_e_fl_random = 3
};
bool StreamCore_FrameLengthMode_IsValid(int value);
const StreamCore_FrameLengthMode StreamCore_FrameLengthMode_FrameLengthMode_MIN = StreamCore_FrameLengthMode_e_fl_fixed;
const StreamCore_FrameLengthMode StreamCore_FrameLengthMode_FrameLengthMode_MAX = StreamCore_FrameLengthMode_e_fl_random;
const int StreamCore_FrameLengthMode_FrameLengthMode_ARRAYSIZE = StreamCore_FrameLengthMode_FrameLengthMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* StreamCore_FrameLengthMode_descriptor();
inline const ::std::string& StreamCore_FrameLengthMode_Name(StreamCore_FrameLengthMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    StreamCore_FrameLengthMode_descriptor(), value);
}
inline bool StreamCore_FrameLengthMode_Parse(
    const ::std::string& name, StreamCore_FrameLengthMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamCore_FrameLengthMode>(
    StreamCore_FrameLengthMode_descriptor(), name, value);
}
enum StreamControl_SendUnit {
  StreamControl_SendUnit_e_su_packets = 0,
  StreamControl_SendUnit_e_su_bursts = 1
};
bool StreamControl_SendUnit_IsValid(int value);
const StreamControl_SendUnit StreamControl_SendUnit_SendUnit_MIN = StreamControl_SendUnit_e_su_packets;
const StreamControl_SendUnit StreamControl_SendUnit_SendUnit_MAX = StreamControl_SendUnit_e_su_bursts;
const int StreamControl_SendUnit_SendUnit_ARRAYSIZE = StreamControl_SendUnit_SendUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* StreamControl_SendUnit_descriptor();
inline const ::std::string& StreamControl_SendUnit_Name(StreamControl_SendUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    StreamControl_SendUnit_descriptor(), value);
}
inline bool StreamControl_SendUnit_Parse(
    const ::std::string& name, StreamControl_SendUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamControl_SendUnit>(
    StreamControl_SendUnit_descriptor(), name, value);
}
enum StreamControl_SendMode {
  StreamControl_SendMode_e_sm_fixed = 0,
  StreamControl_SendMode_e_sm_continuous = 1
};
bool StreamControl_SendMode_IsValid(int value);
const StreamControl_SendMode StreamControl_SendMode_SendMode_MIN = StreamControl_SendMode_e_sm_fixed;
const StreamControl_SendMode StreamControl_SendMode_SendMode_MAX = StreamControl_SendMode_e_sm_continuous;
const int StreamControl_SendMode_SendMode_ARRAYSIZE = StreamControl_SendMode_SendMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* StreamControl_SendMode_descriptor();
inline const ::std::string& StreamControl_SendMode_Name(StreamControl_SendMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    StreamControl_SendMode_descriptor(), value);
}
inline bool StreamControl_SendMode_Parse(
    const ::std::string& name, StreamControl_SendMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamControl_SendMode>(
    StreamControl_SendMode_descriptor(), name, value);
}
enum StreamControl_NextWhat {
  StreamControl_NextWhat_e_nw_stop = 0,
  StreamControl_NextWhat_e_nw_goto_next = 1,
  StreamControl_NextWhat_e_nw_goto_id = 2
};
bool StreamControl_NextWhat_IsValid(int value);
const StreamControl_NextWhat StreamControl_NextWhat_NextWhat_MIN = StreamControl_NextWhat_e_nw_stop;
const StreamControl_NextWhat StreamControl_NextWhat_NextWhat_MAX = StreamControl_NextWhat_e_nw_goto_id;
const int StreamControl_NextWhat_NextWhat_ARRAYSIZE = StreamControl_NextWhat_NextWhat_MAX + 1;

const ::google::protobuf::EnumDescriptor* StreamControl_NextWhat_descriptor();
inline const ::std::string& StreamControl_NextWhat_Name(StreamControl_NextWhat value) {
  return ::google::protobuf::internal::NameOfEnum(
    StreamControl_NextWhat_descriptor(), value);
}
inline bool StreamControl_NextWhat_Parse(
    const ::std::string& name, StreamControl_NextWhat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamControl_NextWhat>(
    StreamControl_NextWhat_descriptor(), name, value);
}
enum Protocol_k {
  Protocol_k_kMacFieldNumber = 100,
  Protocol_k_kPayloadFieldNumber = 101,
  Protocol_k_kSampleFieldNumber = 102,
  Protocol_k_kUserScriptFieldNumber = 103,
  Protocol_k_kHexDumpFieldNumber = 104,
  Protocol_k_kEth2FieldNumber = 200,
  Protocol_k_kDot3FieldNumber = 201,
  Protocol_k_kLlcFieldNumber = 202,
  Protocol_k_kSnapFieldNumber = 203,
  Protocol_k_kSvlanFieldNumber = 204,
  Protocol_k_kVlanFieldNumber = 205,
  Protocol_k_kDot2LlcFieldNumber = 206,
  Protocol_k_kDot2SnapFieldNumber = 207,
  Protocol_k_kVlanStackFieldNumber = 208,
  Protocol_k_kArpFieldNumber = 300,
  Protocol_k_kIp4FieldNumber = 301,
  Protocol_k_kIp6FieldNumber = 302,
  Protocol_k_kIp6over4FieldNumber = 303,
  Protocol_k_kIp4over6FieldNumber = 304,
  Protocol_k_kIp4over4FieldNumber = 305,
  Protocol_k_kIp6over6FieldNumber = 306,
  Protocol_k_kTcpFieldNumber = 400,
  Protocol_k_kUdpFieldNumber = 401,
  Protocol_k_kIcmpFieldNumber = 402,
  Protocol_k_kIgmpFieldNumber = 403,
  Protocol_k_kMldFieldNumber = 404,
  Protocol_k_kTextProtocolFieldNumber = 500
};
bool Protocol_k_IsValid(int value);
const Protocol_k Protocol_k_k_MIN = Protocol_k_kMacFieldNumber;
const Protocol_k Protocol_k_k_MAX = Protocol_k_kTextProtocolFieldNumber;
const int Protocol_k_k_ARRAYSIZE = Protocol_k_k_MAX + 1;

const ::google::protobuf::EnumDescriptor* Protocol_k_descriptor();
inline const ::std::string& Protocol_k_Name(Protocol_k value) {
  return ::google::protobuf::internal::NameOfEnum(
    Protocol_k_descriptor(), value);
}
inline bool Protocol_k_Parse(
    const ::std::string& name, Protocol_k* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Protocol_k>(
    Protocol_k_descriptor(), name, value);
}
enum TransmitMode {
  kSequentialTransmit = 0,
  kInterleavedTransmit = 1
};
bool TransmitMode_IsValid(int value);
const TransmitMode TransmitMode_MIN = kSequentialTransmit;
const TransmitMode TransmitMode_MAX = kInterleavedTransmit;
const int TransmitMode_ARRAYSIZE = TransmitMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransmitMode_descriptor();
inline const ::std::string& TransmitMode_Name(TransmitMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransmitMode_descriptor(), value);
}
inline bool TransmitMode_Parse(
    const ::std::string& name, TransmitMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransmitMode>(
    TransmitMode_descriptor(), name, value);
}
enum LinkState {
  LinkStateUnknown = 0,
  LinkStateDown = 1,
  LinkStateUp = 2
};
bool LinkState_IsValid(int value);
const LinkState LinkState_MIN = LinkStateUnknown;
const LinkState LinkState_MAX = LinkStateUp;
const int LinkState_ARRAYSIZE = LinkState_MAX + 1;

const ::google::protobuf::EnumDescriptor* LinkState_descriptor();
inline const ::std::string& LinkState_Name(LinkState value) {
  return ::google::protobuf::internal::NameOfEnum(
    LinkState_descriptor(), value);
}
inline bool LinkState_Parse(
    const ::std::string& name, LinkState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LinkState>(
    LinkState_descriptor(), name, value);
}
// ===================================================================

class VersionInfo : public ::google::protobuf::Message {
 public:
  VersionInfo();
  virtual ~VersionInfo();
  
  VersionInfo(const VersionInfo& from);
  
  inline VersionInfo& operator=(const VersionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionInfo& default_instance();
  
  void Swap(VersionInfo* other);
  
  // implements Message ----------------------------------------------
  
  VersionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VersionInfo& from);
  void MergeFrom(const VersionInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:OstProto.VersionInfo)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static VersionInfo* default_instance_;
};
// -------------------------------------------------------------------

class VersionCompatibility : public ::google::protobuf::Message {
 public:
  VersionCompatibility();
  virtual ~VersionCompatibility();
  
  VersionCompatibility(const VersionCompatibility& from);
  
  inline VersionCompatibility& operator=(const VersionCompatibility& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionCompatibility& default_instance();
  
  void Swap(VersionCompatibility* other);
  
  // implements Message ----------------------------------------------
  
  VersionCompatibility* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VersionCompatibility& from);
  void MergeFrom(const VersionCompatibility& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef VersionCompatibility_Compatibility Compatibility;
  static const Compatibility kIncompatible = VersionCompatibility_Compatibility_kIncompatible;
  static const Compatibility kCompatible = VersionCompatibility_Compatibility_kCompatible;
  static inline bool Compatibility_IsValid(int value) {
    return VersionCompatibility_Compatibility_IsValid(value);
  }
  static const Compatibility Compatibility_MIN =
    VersionCompatibility_Compatibility_Compatibility_MIN;
  static const Compatibility Compatibility_MAX =
    VersionCompatibility_Compatibility_Compatibility_MAX;
  static const int Compatibility_ARRAYSIZE =
    VersionCompatibility_Compatibility_Compatibility_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Compatibility_descriptor() {
    return VersionCompatibility_Compatibility_descriptor();
  }
  static inline const ::std::string& Compatibility_Name(Compatibility value) {
    return VersionCompatibility_Compatibility_Name(value);
  }
  static inline bool Compatibility_Parse(const ::std::string& name,
      Compatibility* value) {
    return VersionCompatibility_Compatibility_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .OstProto.VersionCompatibility.Compatibility result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::OstProto::VersionCompatibility_Compatibility result() const;
  inline void set_result(::OstProto::VersionCompatibility_Compatibility value);
  
  // optional string notes = 2;
  inline bool has_notes() const;
  inline void clear_notes();
  static const int kNotesFieldNumber = 2;
  inline const ::std::string& notes() const;
  inline void set_notes(const ::std::string& value);
  inline void set_notes(const char* value);
  inline void set_notes(const char* value, size_t size);
  inline ::std::string* mutable_notes();
  inline ::std::string* release_notes();
  
  // @@protoc_insertion_point(class_scope:OstProto.VersionCompatibility)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_notes();
  inline void clear_has_notes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* notes_;
  int result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static VersionCompatibility* default_instance_;
};
// -------------------------------------------------------------------

class StreamId : public ::google::protobuf::Message {
 public:
  StreamId();
  virtual ~StreamId();
  
  StreamId(const StreamId& from);
  
  inline StreamId& operator=(const StreamId& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamId& default_instance();
  
  void Swap(StreamId* other);
  
  // implements Message ----------------------------------------------
  
  StreamId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamId& from);
  void MergeFrom(const StreamId& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OstProto.StreamId)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static StreamId* default_instance_;
};
// -------------------------------------------------------------------

class StreamCore : public ::google::protobuf::Message {
 public:
  StreamCore();
  virtual ~StreamCore();
  
  StreamCore(const StreamCore& from);
  
  inline StreamCore& operator=(const StreamCore& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamCore& default_instance();
  
  void Swap(StreamCore* other);
  
  // implements Message ----------------------------------------------
  
  StreamCore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamCore& from);
  void MergeFrom(const StreamCore& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef StreamCore_FrameLengthMode FrameLengthMode;
  static const FrameLengthMode e_fl_fixed = StreamCore_FrameLengthMode_e_fl_fixed;
  static const FrameLengthMode e_fl_inc = StreamCore_FrameLengthMode_e_fl_inc;
  static const FrameLengthMode e_fl_dec = StreamCore_FrameLengthMode_e_fl_dec;
  static const FrameLengthMode e_fl_random = StreamCore_FrameLengthMode_e_fl_random;
  static inline bool FrameLengthMode_IsValid(int value) {
    return StreamCore_FrameLengthMode_IsValid(value);
  }
  static const FrameLengthMode FrameLengthMode_MIN =
    StreamCore_FrameLengthMode_FrameLengthMode_MIN;
  static const FrameLengthMode FrameLengthMode_MAX =
    StreamCore_FrameLengthMode_FrameLengthMode_MAX;
  static const int FrameLengthMode_ARRAYSIZE =
    StreamCore_FrameLengthMode_FrameLengthMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FrameLengthMode_descriptor() {
    return StreamCore_FrameLengthMode_descriptor();
  }
  static inline const ::std::string& FrameLengthMode_Name(FrameLengthMode value) {
    return StreamCore_FrameLengthMode_Name(value);
  }
  static inline bool FrameLengthMode_Parse(const ::std::string& name,
      FrameLengthMode* value) {
    return StreamCore_FrameLengthMode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional bool is_enabled = 2;
  inline bool has_is_enabled() const;
  inline void clear_is_enabled();
  static const int kIsEnabledFieldNumber = 2;
  inline bool is_enabled() const;
  inline void set_is_enabled(bool value);
  
  // optional uint32 ordinal = 3;
  inline bool has_ordinal() const;
  inline void clear_ordinal();
  static const int kOrdinalFieldNumber = 3;
  inline ::google::protobuf::uint32 ordinal() const;
  inline void set_ordinal(::google::protobuf::uint32 value);
  
  // optional .OstProto.StreamCore.FrameLengthMode len_mode = 14 [default = e_fl_fixed];
  inline bool has_len_mode() const;
  inline void clear_len_mode();
  static const int kLenModeFieldNumber = 14;
  inline ::OstProto::StreamCore_FrameLengthMode len_mode() const;
  inline void set_len_mode(::OstProto::StreamCore_FrameLengthMode value);
  
  // optional uint32 frame_len = 15 [default = 64];
  inline bool has_frame_len() const;
  inline void clear_frame_len();
  static const int kFrameLenFieldNumber = 15;
  inline ::google::protobuf::uint32 frame_len() const;
  inline void set_frame_len(::google::protobuf::uint32 value);
  
  // optional uint32 frame_len_min = 16 [default = 64];
  inline bool has_frame_len_min() const;
  inline void clear_frame_len_min();
  static const int kFrameLenMinFieldNumber = 16;
  inline ::google::protobuf::uint32 frame_len_min() const;
  inline void set_frame_len_min(::google::protobuf::uint32 value);
  
  // optional uint32 frame_len_max = 17 [default = 1518];
  inline bool has_frame_len_max() const;
  inline void clear_frame_len_max();
  static const int kFrameLenMaxFieldNumber = 17;
  inline ::google::protobuf::uint32 frame_len_max() const;
  inline void set_frame_len_max(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OstProto.StreamCore)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_is_enabled();
  inline void clear_has_is_enabled();
  inline void set_has_ordinal();
  inline void clear_has_ordinal();
  inline void set_has_len_mode();
  inline void clear_has_len_mode();
  inline void set_has_frame_len();
  inline void clear_has_frame_len();
  inline void set_has_frame_len_min();
  inline void clear_has_frame_len_min();
  inline void set_has_frame_len_max();
  inline void clear_has_frame_len_max();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  bool is_enabled_;
  ::google::protobuf::uint32 ordinal_;
  int len_mode_;
  ::google::protobuf::uint32 frame_len_;
  ::google::protobuf::uint32 frame_len_min_;
  ::google::protobuf::uint32 frame_len_max_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static StreamCore* default_instance_;
};
// -------------------------------------------------------------------

class StreamControl : public ::google::protobuf::Message {
 public:
  StreamControl();
  virtual ~StreamControl();
  
  StreamControl(const StreamControl& from);
  
  inline StreamControl& operator=(const StreamControl& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamControl& default_instance();
  
  void Swap(StreamControl* other);
  
  // implements Message ----------------------------------------------
  
  StreamControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamControl& from);
  void MergeFrom(const StreamControl& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef StreamControl_SendUnit SendUnit;
  static const SendUnit e_su_packets = StreamControl_SendUnit_e_su_packets;
  static const SendUnit e_su_bursts = StreamControl_SendUnit_e_su_bursts;
  static inline bool SendUnit_IsValid(int value) {
    return StreamControl_SendUnit_IsValid(value);
  }
  static const SendUnit SendUnit_MIN =
    StreamControl_SendUnit_SendUnit_MIN;
  static const SendUnit SendUnit_MAX =
    StreamControl_SendUnit_SendUnit_MAX;
  static const int SendUnit_ARRAYSIZE =
    StreamControl_SendUnit_SendUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SendUnit_descriptor() {
    return StreamControl_SendUnit_descriptor();
  }
  static inline const ::std::string& SendUnit_Name(SendUnit value) {
    return StreamControl_SendUnit_Name(value);
  }
  static inline bool SendUnit_Parse(const ::std::string& name,
      SendUnit* value) {
    return StreamControl_SendUnit_Parse(name, value);
  }
  
  typedef StreamControl_SendMode SendMode;
  static const SendMode e_sm_fixed = StreamControl_SendMode_e_sm_fixed;
  static const SendMode e_sm_continuous = StreamControl_SendMode_e_sm_continuous;
  static inline bool SendMode_IsValid(int value) {
    return StreamControl_SendMode_IsValid(value);
  }
  static const SendMode SendMode_MIN =
    StreamControl_SendMode_SendMode_MIN;
  static const SendMode SendMode_MAX =
    StreamControl_SendMode_SendMode_MAX;
  static const int SendMode_ARRAYSIZE =
    StreamControl_SendMode_SendMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SendMode_descriptor() {
    return StreamControl_SendMode_descriptor();
  }
  static inline const ::std::string& SendMode_Name(SendMode value) {
    return StreamControl_SendMode_Name(value);
  }
  static inline bool SendMode_Parse(const ::std::string& name,
      SendMode* value) {
    return StreamControl_SendMode_Parse(name, value);
  }
  
  typedef StreamControl_NextWhat NextWhat;
  static const NextWhat e_nw_stop = StreamControl_NextWhat_e_nw_stop;
  static const NextWhat e_nw_goto_next = StreamControl_NextWhat_e_nw_goto_next;
  static const NextWhat e_nw_goto_id = StreamControl_NextWhat_e_nw_goto_id;
  static inline bool NextWhat_IsValid(int value) {
    return StreamControl_NextWhat_IsValid(value);
  }
  static const NextWhat NextWhat_MIN =
    StreamControl_NextWhat_NextWhat_MIN;
  static const NextWhat NextWhat_MAX =
    StreamControl_NextWhat_NextWhat_MAX;
  static const int NextWhat_ARRAYSIZE =
    StreamControl_NextWhat_NextWhat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NextWhat_descriptor() {
    return StreamControl_NextWhat_descriptor();
  }
  static inline const ::std::string& NextWhat_Name(NextWhat value) {
    return StreamControl_NextWhat_Name(value);
  }
  static inline bool NextWhat_Parse(const ::std::string& name,
      NextWhat* value) {
    return StreamControl_NextWhat_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .OstProto.StreamControl.SendUnit unit = 1 [default = e_su_packets];
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline ::OstProto::StreamControl_SendUnit unit() const;
  inline void set_unit(::OstProto::StreamControl_SendUnit value);
  
  // optional .OstProto.StreamControl.SendMode mode = 2 [default = e_sm_fixed];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::OstProto::StreamControl_SendMode mode() const;
  inline void set_mode(::OstProto::StreamControl_SendMode value);
  
  // optional uint32 num_packets = 3 [default = 1];
  inline bool has_num_packets() const;
  inline void clear_num_packets();
  static const int kNumPacketsFieldNumber = 3;
  inline ::google::protobuf::uint32 num_packets() const;
  inline void set_num_packets(::google::protobuf::uint32 value);
  
  // optional uint32 num_bursts = 4 [default = 1];
  inline bool has_num_bursts() const;
  inline void clear_num_bursts();
  static const int kNumBurstsFieldNumber = 4;
  inline ::google::protobuf::uint32 num_bursts() const;
  inline void set_num_bursts(::google::protobuf::uint32 value);
  
  // optional uint32 packets_per_burst = 5 [default = 10];
  inline bool has_packets_per_burst() const;
  inline void clear_packets_per_burst();
  static const int kPacketsPerBurstFieldNumber = 5;
  inline ::google::protobuf::uint32 packets_per_burst() const;
  inline void set_packets_per_burst(::google::protobuf::uint32 value);
  
  // optional .OstProto.StreamControl.NextWhat next = 6 [default = e_nw_goto_next];
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 6;
  inline ::OstProto::StreamControl_NextWhat next() const;
  inline void set_next(::OstProto::StreamControl_NextWhat value);
  
  // optional uint32 OBSOLETE_packets_per_sec = 7 [default = 1, deprecated = true];
  inline bool has_obsolete_packets_per_sec() const PROTOBUF_DEPRECATED;
  inline void clear_obsolete_packets_per_sec() PROTOBUF_DEPRECATED;
  static const int kOBSOLETEPacketsPerSecFieldNumber = 7;
  inline ::google::protobuf::uint32 obsolete_packets_per_sec() const PROTOBUF_DEPRECATED;
  inline void set_obsolete_packets_per_sec(::google::protobuf::uint32 value) PROTOBUF_DEPRECATED;
  
  // optional uint32 OBSOLETE_bursts_per_sec = 8 [default = 1, deprecated = true];
  inline bool has_obsolete_bursts_per_sec() const PROTOBUF_DEPRECATED;
  inline void clear_obsolete_bursts_per_sec() PROTOBUF_DEPRECATED;
  static const int kOBSOLETEBurstsPerSecFieldNumber = 8;
  inline ::google::protobuf::uint32 obsolete_bursts_per_sec() const PROTOBUF_DEPRECATED;
  inline void set_obsolete_bursts_per_sec(::google::protobuf::uint32 value) PROTOBUF_DEPRECATED;
  
  // optional double packets_per_sec = 9 [default = 1];
  inline bool has_packets_per_sec() const;
  inline void clear_packets_per_sec();
  static const int kPacketsPerSecFieldNumber = 9;
  inline double packets_per_sec() const;
  inline void set_packets_per_sec(double value);
  
  // optional double bursts_per_sec = 10 [default = 1];
  inline bool has_bursts_per_sec() const;
  inline void clear_bursts_per_sec();
  static const int kBurstsPerSecFieldNumber = 10;
  inline double bursts_per_sec() const;
  inline void set_bursts_per_sec(double value);
  
  // @@protoc_insertion_point(class_scope:OstProto.StreamControl)
 private:
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_num_packets();
  inline void clear_has_num_packets();
  inline void set_has_num_bursts();
  inline void clear_has_num_bursts();
  inline void set_has_packets_per_burst();
  inline void clear_has_packets_per_burst();
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_obsolete_packets_per_sec();
  inline void clear_has_obsolete_packets_per_sec();
  inline void set_has_obsolete_bursts_per_sec();
  inline void clear_has_obsolete_bursts_per_sec();
  inline void set_has_packets_per_sec();
  inline void clear_has_packets_per_sec();
  inline void set_has_bursts_per_sec();
  inline void clear_has_bursts_per_sec();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int unit_;
  int mode_;
  ::google::protobuf::uint32 num_packets_;
  ::google::protobuf::uint32 num_bursts_;
  ::google::protobuf::uint32 packets_per_burst_;
  int next_;
  ::google::protobuf::uint32 obsolete_packets_per_sec_;
  ::google::protobuf::uint32 obsolete_bursts_per_sec_;
  double packets_per_sec_;
  double bursts_per_sec_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static StreamControl* default_instance_;
};
// -------------------------------------------------------------------

class ProtocolId : public ::google::protobuf::Message {
 public:
  ProtocolId();
  virtual ~ProtocolId();
  
  ProtocolId(const ProtocolId& from);
  
  inline ProtocolId& operator=(const ProtocolId& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtocolId& default_instance();
  
  void Swap(ProtocolId* other);
  
  // implements Message ----------------------------------------------
  
  ProtocolId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtocolId& from);
  void MergeFrom(const ProtocolId& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OstProto.ProtocolId)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static ProtocolId* default_instance_;
};
// -------------------------------------------------------------------

class Protocol : public ::google::protobuf::Message {
 public:
  Protocol();
  virtual ~Protocol();
  
  Protocol(const Protocol& from);
  
  inline Protocol& operator=(const Protocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Protocol& default_instance();
  
  void Swap(Protocol* other);
  
  // implements Message ----------------------------------------------
  
  Protocol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Protocol& from);
  void MergeFrom(const Protocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Protocol_k k;
  static const k kMacFieldNumber = Protocol_k_kMacFieldNumber;
  static const k kPayloadFieldNumber = Protocol_k_kPayloadFieldNumber;
  static const k kSampleFieldNumber = Protocol_k_kSampleFieldNumber;
  static const k kUserScriptFieldNumber = Protocol_k_kUserScriptFieldNumber;
  static const k kHexDumpFieldNumber = Protocol_k_kHexDumpFieldNumber;
  static const k kEth2FieldNumber = Protocol_k_kEth2FieldNumber;
  static const k kDot3FieldNumber = Protocol_k_kDot3FieldNumber;
  static const k kLlcFieldNumber = Protocol_k_kLlcFieldNumber;
  static const k kSnapFieldNumber = Protocol_k_kSnapFieldNumber;
  static const k kSvlanFieldNumber = Protocol_k_kSvlanFieldNumber;
  static const k kVlanFieldNumber = Protocol_k_kVlanFieldNumber;
  static const k kDot2LlcFieldNumber = Protocol_k_kDot2LlcFieldNumber;
  static const k kDot2SnapFieldNumber = Protocol_k_kDot2SnapFieldNumber;
  static const k kVlanStackFieldNumber = Protocol_k_kVlanStackFieldNumber;
  static const k kArpFieldNumber = Protocol_k_kArpFieldNumber;
  static const k kIp4FieldNumber = Protocol_k_kIp4FieldNumber;
  static const k kIp6FieldNumber = Protocol_k_kIp6FieldNumber;
  static const k kIp6over4FieldNumber = Protocol_k_kIp6over4FieldNumber;
  static const k kIp4over6FieldNumber = Protocol_k_kIp4over6FieldNumber;
  static const k kIp4over4FieldNumber = Protocol_k_kIp4over4FieldNumber;
  static const k kIp6over6FieldNumber = Protocol_k_kIp6over6FieldNumber;
  static const k kTcpFieldNumber = Protocol_k_kTcpFieldNumber;
  static const k kUdpFieldNumber = Protocol_k_kUdpFieldNumber;
  static const k kIcmpFieldNumber = Protocol_k_kIcmpFieldNumber;
  static const k kIgmpFieldNumber = Protocol_k_kIgmpFieldNumber;
  static const k kMldFieldNumber = Protocol_k_kMldFieldNumber;
  static const k kTextProtocolFieldNumber = Protocol_k_kTextProtocolFieldNumber;
  static inline bool k_IsValid(int value) {
    return Protocol_k_IsValid(value);
  }
  static const k k_MIN =
    Protocol_k_k_MIN;
  static const k k_MAX =
    Protocol_k_k_MAX;
  static const int k_ARRAYSIZE =
    Protocol_k_k_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  k_descriptor() {
    return Protocol_k_descriptor();
  }
  static inline const ::std::string& k_Name(k value) {
    return Protocol_k_Name(value);
  }
  static inline bool k_Parse(const ::std::string& name,
      k* value) {
    return Protocol_k_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .OstProto.ProtocolId protocol_id = 1;
  inline bool has_protocol_id() const;
  inline void clear_protocol_id();
  static const int kProtocolIdFieldNumber = 1;
  inline const ::OstProto::ProtocolId& protocol_id() const;
  inline ::OstProto::ProtocolId* mutable_protocol_id();
  inline ::OstProto::ProtocolId* release_protocol_id();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Protocol)
  // @@protoc_insertion_point(class_scope:OstProto.Protocol)
 private:
  inline void set_has_protocol_id();
  inline void clear_has_protocol_id();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::OstProto::ProtocolId* protocol_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static Protocol* default_instance_;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message {
 public:
  Stream();
  virtual ~Stream();
  
  Stream(const Stream& from);
  
  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();
  
  void Swap(Stream* other);
  
  // implements Message ----------------------------------------------
  
  Stream* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .OstProto.StreamId stream_id = 1;
  inline bool has_stream_id() const;
  inline void clear_stream_id();
  static const int kStreamIdFieldNumber = 1;
  inline const ::OstProto::StreamId& stream_id() const;
  inline ::OstProto::StreamId* mutable_stream_id();
  inline ::OstProto::StreamId* release_stream_id();
  
  // optional .OstProto.StreamCore core = 2;
  inline bool has_core() const;
  inline void clear_core();
  static const int kCoreFieldNumber = 2;
  inline const ::OstProto::StreamCore& core() const;
  inline ::OstProto::StreamCore* mutable_core();
  inline ::OstProto::StreamCore* release_core();
  
  // optional .OstProto.StreamControl control = 3;
  inline bool has_control() const;
  inline void clear_control();
  static const int kControlFieldNumber = 3;
  inline const ::OstProto::StreamControl& control() const;
  inline ::OstProto::StreamControl* mutable_control();
  inline ::OstProto::StreamControl* release_control();
  
  // repeated .OstProto.Protocol protocol = 4;
  inline int protocol_size() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 4;
  inline const ::OstProto::Protocol& protocol(int index) const;
  inline ::OstProto::Protocol* mutable_protocol(int index);
  inline ::OstProto::Protocol* add_protocol();
  inline const ::google::protobuf::RepeatedPtrField< ::OstProto::Protocol >&
      protocol() const;
  inline ::google::protobuf::RepeatedPtrField< ::OstProto::Protocol >*
      mutable_protocol();
  
  // @@protoc_insertion_point(class_scope:OstProto.Stream)
 private:
  inline void set_has_stream_id();
  inline void clear_has_stream_id();
  inline void set_has_core();
  inline void clear_has_core();
  inline void set_has_control();
  inline void clear_has_control();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::OstProto::StreamId* stream_id_;
  ::OstProto::StreamCore* core_;
  ::OstProto::StreamControl* control_;
  ::google::protobuf::RepeatedPtrField< ::OstProto::Protocol > protocol_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static Stream* default_instance_;
};
// -------------------------------------------------------------------

class Void : public ::google::protobuf::Message {
 public:
  Void();
  virtual ~Void();
  
  Void(const Void& from);
  
  inline Void& operator=(const Void& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Void& default_instance();
  
  void Swap(Void* other);
  
  // implements Message ----------------------------------------------
  
  Void* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Void& from);
  void MergeFrom(const Void& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:OstProto.Void)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static Void* default_instance_;
};
// -------------------------------------------------------------------

class Ack : public ::google::protobuf::Message {
 public:
  Ack();
  virtual ~Ack();
  
  Ack(const Ack& from);
  
  inline Ack& operator=(const Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ack& default_instance();
  
  void Swap(Ack* other);
  
  // implements Message ----------------------------------------------
  
  Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ack& from);
  void MergeFrom(const Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:OstProto.Ack)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static Ack* default_instance_;
};
// -------------------------------------------------------------------

class PortId : public ::google::protobuf::Message {
 public:
  PortId();
  virtual ~PortId();
  
  PortId(const PortId& from);
  
  inline PortId& operator=(const PortId& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortId& default_instance();
  
  void Swap(PortId* other);
  
  // implements Message ----------------------------------------------
  
  PortId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortId& from);
  void MergeFrom(const PortId& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OstProto.PortId)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static PortId* default_instance_;
};
// -------------------------------------------------------------------

class PortIdList : public ::google::protobuf::Message {
 public:
  PortIdList();
  virtual ~PortIdList();
  
  PortIdList(const PortIdList& from);
  
  inline PortIdList& operator=(const PortIdList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortIdList& default_instance();
  
  void Swap(PortIdList* other);
  
  // implements Message ----------------------------------------------
  
  PortIdList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortIdList& from);
  void MergeFrom(const PortIdList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .OstProto.PortId port_id = 1;
  inline int port_id_size() const;
  inline void clear_port_id();
  static const int kPortIdFieldNumber = 1;
  inline const ::OstProto::PortId& port_id(int index) const;
  inline ::OstProto::PortId* mutable_port_id(int index);
  inline ::OstProto::PortId* add_port_id();
  inline const ::google::protobuf::RepeatedPtrField< ::OstProto::PortId >&
      port_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::OstProto::PortId >*
      mutable_port_id();
  
  // @@protoc_insertion_point(class_scope:OstProto.PortIdList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::OstProto::PortId > port_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static PortIdList* default_instance_;
};
// -------------------------------------------------------------------

class StreamIdList : public ::google::protobuf::Message {
 public:
  StreamIdList();
  virtual ~StreamIdList();
  
  StreamIdList(const StreamIdList& from);
  
  inline StreamIdList& operator=(const StreamIdList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamIdList& default_instance();
  
  void Swap(StreamIdList* other);
  
  // implements Message ----------------------------------------------
  
  StreamIdList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamIdList& from);
  void MergeFrom(const StreamIdList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .OstProto.PortId port_id = 1;
  inline bool has_port_id() const;
  inline void clear_port_id();
  static const int kPortIdFieldNumber = 1;
  inline const ::OstProto::PortId& port_id() const;
  inline ::OstProto::PortId* mutable_port_id();
  inline ::OstProto::PortId* release_port_id();
  
  // repeated .OstProto.StreamId stream_id = 2;
  inline int stream_id_size() const;
  inline void clear_stream_id();
  static const int kStreamIdFieldNumber = 2;
  inline const ::OstProto::StreamId& stream_id(int index) const;
  inline ::OstProto::StreamId* mutable_stream_id(int index);
  inline ::OstProto::StreamId* add_stream_id();
  inline const ::google::protobuf::RepeatedPtrField< ::OstProto::StreamId >&
      stream_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::OstProto::StreamId >*
      mutable_stream_id();
  
  // @@protoc_insertion_point(class_scope:OstProto.StreamIdList)
 private:
  inline void set_has_port_id();
  inline void clear_has_port_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::OstProto::PortId* port_id_;
  ::google::protobuf::RepeatedPtrField< ::OstProto::StreamId > stream_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static StreamIdList* default_instance_;
};
// -------------------------------------------------------------------

class Port : public ::google::protobuf::Message {
 public:
  Port();
  virtual ~Port();
  
  Port(const Port& from);
  
  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Port& default_instance();
  
  void Swap(Port* other);
  
  // implements Message ----------------------------------------------
  
  Port* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Port& from);
  void MergeFrom(const Port& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .OstProto.PortId port_id = 1;
  inline bool has_port_id() const;
  inline void clear_port_id();
  static const int kPortIdFieldNumber = 1;
  inline const ::OstProto::PortId& port_id() const;
  inline ::OstProto::PortId* mutable_port_id();
  inline ::OstProto::PortId* release_port_id();
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string description = 3;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 3;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional string notes = 4;
  inline bool has_notes() const;
  inline void clear_notes();
  static const int kNotesFieldNumber = 4;
  inline const ::std::string& notes() const;
  inline void set_notes(const ::std::string& value);
  inline void set_notes(const char* value);
  inline void set_notes(const char* value, size_t size);
  inline ::std::string* mutable_notes();
  inline ::std::string* release_notes();
  
  // optional bool is_enabled = 5;
  inline bool has_is_enabled() const;
  inline void clear_is_enabled();
  static const int kIsEnabledFieldNumber = 5;
  inline bool is_enabled() const;
  inline void set_is_enabled(bool value);
  
  // optional bool is_exclusive_control = 6;
  inline bool has_is_exclusive_control() const;
  inline void clear_is_exclusive_control();
  static const int kIsExclusiveControlFieldNumber = 6;
  inline bool is_exclusive_control() const;
  inline void set_is_exclusive_control(bool value);
  
  // optional .OstProto.TransmitMode transmit_mode = 7 [default = kSequentialTransmit];
  inline bool has_transmit_mode() const;
  inline void clear_transmit_mode();
  static const int kTransmitModeFieldNumber = 7;
  inline OstProto::TransmitMode transmit_mode() const;
  inline void set_transmit_mode(OstProto::TransmitMode value);
  
  // @@protoc_insertion_point(class_scope:OstProto.Port)
 private:
  inline void set_has_port_id();
  inline void clear_has_port_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_notes();
  inline void clear_has_notes();
  inline void set_has_is_enabled();
  inline void clear_has_is_enabled();
  inline void set_has_is_exclusive_control();
  inline void clear_has_is_exclusive_control();
  inline void set_has_transmit_mode();
  inline void clear_has_transmit_mode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::OstProto::PortId* port_id_;
  ::std::string* name_;
  ::std::string* description_;
  ::std::string* notes_;
  bool is_enabled_;
  bool is_exclusive_control_;
  int transmit_mode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static Port* default_instance_;
};
// -------------------------------------------------------------------

class PortConfigList : public ::google::protobuf::Message {
 public:
  PortConfigList();
  virtual ~PortConfigList();
  
  PortConfigList(const PortConfigList& from);
  
  inline PortConfigList& operator=(const PortConfigList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortConfigList& default_instance();
  
  void Swap(PortConfigList* other);
  
  // implements Message ----------------------------------------------
  
  PortConfigList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortConfigList& from);
  void MergeFrom(const PortConfigList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .OstProto.Port port = 1;
  inline int port_size() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline const ::OstProto::Port& port(int index) const;
  inline ::OstProto::Port* mutable_port(int index);
  inline ::OstProto::Port* add_port();
  inline const ::google::protobuf::RepeatedPtrField< ::OstProto::Port >&
      port() const;
  inline ::google::protobuf::RepeatedPtrField< ::OstProto::Port >*
      mutable_port();
  
  // @@protoc_insertion_point(class_scope:OstProto.PortConfigList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::OstProto::Port > port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static PortConfigList* default_instance_;
};
// -------------------------------------------------------------------

class StreamConfigList : public ::google::protobuf::Message {
 public:
  StreamConfigList();
  virtual ~StreamConfigList();
  
  StreamConfigList(const StreamConfigList& from);
  
  inline StreamConfigList& operator=(const StreamConfigList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamConfigList& default_instance();
  
  void Swap(StreamConfigList* other);
  
  // implements Message ----------------------------------------------
  
  StreamConfigList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamConfigList& from);
  void MergeFrom(const StreamConfigList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .OstProto.PortId port_id = 1;
  inline bool has_port_id() const;
  inline void clear_port_id();
  static const int kPortIdFieldNumber = 1;
  inline const ::OstProto::PortId& port_id() const;
  inline ::OstProto::PortId* mutable_port_id();
  inline ::OstProto::PortId* release_port_id();
  
  // repeated .OstProto.Stream stream = 2;
  inline int stream_size() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 2;
  inline const ::OstProto::Stream& stream(int index) const;
  inline ::OstProto::Stream* mutable_stream(int index);
  inline ::OstProto::Stream* add_stream();
  inline const ::google::protobuf::RepeatedPtrField< ::OstProto::Stream >&
      stream() const;
  inline ::google::protobuf::RepeatedPtrField< ::OstProto::Stream >*
      mutable_stream();
  
  // @@protoc_insertion_point(class_scope:OstProto.StreamConfigList)
 private:
  inline void set_has_port_id();
  inline void clear_has_port_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::OstProto::PortId* port_id_;
  ::google::protobuf::RepeatedPtrField< ::OstProto::Stream > stream_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static StreamConfigList* default_instance_;
};
// -------------------------------------------------------------------

class CaptureBuffer : public ::google::protobuf::Message {
 public:
  CaptureBuffer();
  virtual ~CaptureBuffer();
  
  CaptureBuffer(const CaptureBuffer& from);
  
  inline CaptureBuffer& operator=(const CaptureBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CaptureBuffer& default_instance();
  
  void Swap(CaptureBuffer* other);
  
  // implements Message ----------------------------------------------
  
  CaptureBuffer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaptureBuffer& from);
  void MergeFrom(const CaptureBuffer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:OstProto.CaptureBuffer)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static CaptureBuffer* default_instance_;
};
// -------------------------------------------------------------------

class CaptureBufferList : public ::google::protobuf::Message {
 public:
  CaptureBufferList();
  virtual ~CaptureBufferList();
  
  CaptureBufferList(const CaptureBufferList& from);
  
  inline CaptureBufferList& operator=(const CaptureBufferList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CaptureBufferList& default_instance();
  
  void Swap(CaptureBufferList* other);
  
  // implements Message ----------------------------------------------
  
  CaptureBufferList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaptureBufferList& from);
  void MergeFrom(const CaptureBufferList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .OstProto.CaptureBuffer list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::OstProto::CaptureBuffer& list(int index) const;
  inline ::OstProto::CaptureBuffer* mutable_list(int index);
  inline ::OstProto::CaptureBuffer* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::OstProto::CaptureBuffer >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::OstProto::CaptureBuffer >*
      mutable_list();
  
  // @@protoc_insertion_point(class_scope:OstProto.CaptureBufferList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::OstProto::CaptureBuffer > list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static CaptureBufferList* default_instance_;
};
// -------------------------------------------------------------------

class PortState : public ::google::protobuf::Message {
 public:
  PortState();
  virtual ~PortState();
  
  PortState(const PortState& from);
  
  inline PortState& operator=(const PortState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortState& default_instance();
  
  void Swap(PortState* other);
  
  // implements Message ----------------------------------------------
  
  PortState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortState& from);
  void MergeFrom(const PortState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .OstProto.LinkState link_state = 1 [default = LinkStateUnknown];
  inline bool has_link_state() const;
  inline void clear_link_state();
  static const int kLinkStateFieldNumber = 1;
  inline OstProto::LinkState link_state() const;
  inline void set_link_state(OstProto::LinkState value);
  
  // optional bool is_transmit_on = 2 [default = false];
  inline bool has_is_transmit_on() const;
  inline void clear_is_transmit_on();
  static const int kIsTransmitOnFieldNumber = 2;
  inline bool is_transmit_on() const;
  inline void set_is_transmit_on(bool value);
  
  // optional bool is_capture_on = 3 [default = false];
  inline bool has_is_capture_on() const;
  inline void clear_is_capture_on();
  static const int kIsCaptureOnFieldNumber = 3;
  inline bool is_capture_on() const;
  inline void set_is_capture_on(bool value);
  
  // @@protoc_insertion_point(class_scope:OstProto.PortState)
 private:
  inline void set_has_link_state();
  inline void clear_has_link_state();
  inline void set_has_is_transmit_on();
  inline void clear_has_is_transmit_on();
  inline void set_has_is_capture_on();
  inline void clear_has_is_capture_on();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int link_state_;
  bool is_transmit_on_;
  bool is_capture_on_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static PortState* default_instance_;
};
// -------------------------------------------------------------------

class PortStats : public ::google::protobuf::Message {
 public:
  PortStats();
  virtual ~PortStats();
  
  PortStats(const PortStats& from);
  
  inline PortStats& operator=(const PortStats& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortStats& default_instance();
  
  void Swap(PortStats* other);
  
  // implements Message ----------------------------------------------
  
  PortStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortStats& from);
  void MergeFrom(const PortStats& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .OstProto.PortId port_id = 1;
  inline bool has_port_id() const;
  inline void clear_port_id();
  static const int kPortIdFieldNumber = 1;
  inline const ::OstProto::PortId& port_id() const;
  inline ::OstProto::PortId* mutable_port_id();
  inline ::OstProto::PortId* release_port_id();
  
  // optional .OstProto.PortState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::OstProto::PortState& state() const;
  inline ::OstProto::PortState* mutable_state();
  inline ::OstProto::PortState* release_state();
  
  // optional uint64 rx_pkts = 11;
  inline bool has_rx_pkts() const;
  inline void clear_rx_pkts();
  static const int kRxPktsFieldNumber = 11;
  inline ::google::protobuf::uint64 rx_pkts() const;
  inline void set_rx_pkts(::google::protobuf::uint64 value);
  
  // optional uint64 rx_bytes = 12;
  inline bool has_rx_bytes() const;
  inline void clear_rx_bytes();
  static const int kRxBytesFieldNumber = 12;
  inline ::google::protobuf::uint64 rx_bytes() const;
  inline void set_rx_bytes(::google::protobuf::uint64 value);
  
  // optional uint64 rx_pkts_nic = 13;
  inline bool has_rx_pkts_nic() const;
  inline void clear_rx_pkts_nic();
  static const int kRxPktsNicFieldNumber = 13;
  inline ::google::protobuf::uint64 rx_pkts_nic() const;
  inline void set_rx_pkts_nic(::google::protobuf::uint64 value);
  
  // optional uint64 rx_bytes_nic = 14;
  inline bool has_rx_bytes_nic() const;
  inline void clear_rx_bytes_nic();
  static const int kRxBytesNicFieldNumber = 14;
  inline ::google::protobuf::uint64 rx_bytes_nic() const;
  inline void set_rx_bytes_nic(::google::protobuf::uint64 value);
  
  // optional uint64 rx_pps = 15;
  inline bool has_rx_pps() const;
  inline void clear_rx_pps();
  static const int kRxPpsFieldNumber = 15;
  inline ::google::protobuf::uint64 rx_pps() const;
  inline void set_rx_pps(::google::protobuf::uint64 value);
  
  // optional uint64 rx_bps = 16;
  inline bool has_rx_bps() const;
  inline void clear_rx_bps();
  static const int kRxBpsFieldNumber = 16;
  inline ::google::protobuf::uint64 rx_bps() const;
  inline void set_rx_bps(::google::protobuf::uint64 value);
  
  // optional uint64 tx_pkts = 21;
  inline bool has_tx_pkts() const;
  inline void clear_tx_pkts();
  static const int kTxPktsFieldNumber = 21;
  inline ::google::protobuf::uint64 tx_pkts() const;
  inline void set_tx_pkts(::google::protobuf::uint64 value);
  
  // optional uint64 tx_bytes = 22;
  inline bool has_tx_bytes() const;
  inline void clear_tx_bytes();
  static const int kTxBytesFieldNumber = 22;
  inline ::google::protobuf::uint64 tx_bytes() const;
  inline void set_tx_bytes(::google::protobuf::uint64 value);
  
  // optional uint64 tx_pkts_nic = 23;
  inline bool has_tx_pkts_nic() const;
  inline void clear_tx_pkts_nic();
  static const int kTxPktsNicFieldNumber = 23;
  inline ::google::protobuf::uint64 tx_pkts_nic() const;
  inline void set_tx_pkts_nic(::google::protobuf::uint64 value);
  
  // optional uint64 tx_bytes_nic = 24;
  inline bool has_tx_bytes_nic() const;
  inline void clear_tx_bytes_nic();
  static const int kTxBytesNicFieldNumber = 24;
  inline ::google::protobuf::uint64 tx_bytes_nic() const;
  inline void set_tx_bytes_nic(::google::protobuf::uint64 value);
  
  // optional uint64 tx_pps = 25;
  inline bool has_tx_pps() const;
  inline void clear_tx_pps();
  static const int kTxPpsFieldNumber = 25;
  inline ::google::protobuf::uint64 tx_pps() const;
  inline void set_tx_pps(::google::protobuf::uint64 value);
  
  // optional uint64 tx_bps = 26;
  inline bool has_tx_bps() const;
  inline void clear_tx_bps();
  static const int kTxBpsFieldNumber = 26;
  inline ::google::protobuf::uint64 tx_bps() const;
  inline void set_tx_bps(::google::protobuf::uint64 value);
  
  // optional uint64 rx_drops = 100;
  inline bool has_rx_drops() const;
  inline void clear_rx_drops();
  static const int kRxDropsFieldNumber = 100;
  inline ::google::protobuf::uint64 rx_drops() const;
  inline void set_rx_drops(::google::protobuf::uint64 value);
  
  // optional uint64 rx_errors = 101;
  inline bool has_rx_errors() const;
  inline void clear_rx_errors();
  static const int kRxErrorsFieldNumber = 101;
  inline ::google::protobuf::uint64 rx_errors() const;
  inline void set_rx_errors(::google::protobuf::uint64 value);
  
  // optional uint64 rx_fifo_errors = 102;
  inline bool has_rx_fifo_errors() const;
  inline void clear_rx_fifo_errors();
  static const int kRxFifoErrorsFieldNumber = 102;
  inline ::google::protobuf::uint64 rx_fifo_errors() const;
  inline void set_rx_fifo_errors(::google::protobuf::uint64 value);
  
  // optional uint64 rx_frame_errors = 103;
  inline bool has_rx_frame_errors() const;
  inline void clear_rx_frame_errors();
  static const int kRxFrameErrorsFieldNumber = 103;
  inline ::google::protobuf::uint64 rx_frame_errors() const;
  inline void set_rx_frame_errors(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:OstProto.PortStats)
 private:
  inline void set_has_port_id();
  inline void clear_has_port_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_rx_pkts();
  inline void clear_has_rx_pkts();
  inline void set_has_rx_bytes();
  inline void clear_has_rx_bytes();
  inline void set_has_rx_pkts_nic();
  inline void clear_has_rx_pkts_nic();
  inline void set_has_rx_bytes_nic();
  inline void clear_has_rx_bytes_nic();
  inline void set_has_rx_pps();
  inline void clear_has_rx_pps();
  inline void set_has_rx_bps();
  inline void clear_has_rx_bps();
  inline void set_has_tx_pkts();
  inline void clear_has_tx_pkts();
  inline void set_has_tx_bytes();
  inline void clear_has_tx_bytes();
  inline void set_has_tx_pkts_nic();
  inline void clear_has_tx_pkts_nic();
  inline void set_has_tx_bytes_nic();
  inline void clear_has_tx_bytes_nic();
  inline void set_has_tx_pps();
  inline void clear_has_tx_pps();
  inline void set_has_tx_bps();
  inline void clear_has_tx_bps();
  inline void set_has_rx_drops();
  inline void clear_has_rx_drops();
  inline void set_has_rx_errors();
  inline void clear_has_rx_errors();
  inline void set_has_rx_fifo_errors();
  inline void clear_has_rx_fifo_errors();
  inline void set_has_rx_frame_errors();
  inline void clear_has_rx_frame_errors();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::OstProto::PortId* port_id_;
  ::OstProto::PortState* state_;
  ::google::protobuf::uint64 rx_pkts_;
  ::google::protobuf::uint64 rx_bytes_;
  ::google::protobuf::uint64 rx_pkts_nic_;
  ::google::protobuf::uint64 rx_bytes_nic_;
  ::google::protobuf::uint64 rx_pps_;
  ::google::protobuf::uint64 rx_bps_;
  ::google::protobuf::uint64 tx_pkts_;
  ::google::protobuf::uint64 tx_bytes_;
  ::google::protobuf::uint64 tx_pkts_nic_;
  ::google::protobuf::uint64 tx_bytes_nic_;
  ::google::protobuf::uint64 tx_pps_;
  ::google::protobuf::uint64 tx_bps_;
  ::google::protobuf::uint64 rx_drops_;
  ::google::protobuf::uint64 rx_errors_;
  ::google::protobuf::uint64 rx_fifo_errors_;
  ::google::protobuf::uint64 rx_frame_errors_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static PortStats* default_instance_;
};
// -------------------------------------------------------------------

class PortStatsList : public ::google::protobuf::Message {
 public:
  PortStatsList();
  virtual ~PortStatsList();
  
  PortStatsList(const PortStatsList& from);
  
  inline PortStatsList& operator=(const PortStatsList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortStatsList& default_instance();
  
  void Swap(PortStatsList* other);
  
  // implements Message ----------------------------------------------
  
  PortStatsList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortStatsList& from);
  void MergeFrom(const PortStatsList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .OstProto.PortStats port_stats = 1;
  inline int port_stats_size() const;
  inline void clear_port_stats();
  static const int kPortStatsFieldNumber = 1;
  inline const ::OstProto::PortStats& port_stats(int index) const;
  inline ::OstProto::PortStats* mutable_port_stats(int index);
  inline ::OstProto::PortStats* add_port_stats();
  inline const ::google::protobuf::RepeatedPtrField< ::OstProto::PortStats >&
      port_stats() const;
  inline ::google::protobuf::RepeatedPtrField< ::OstProto::PortStats >*
      mutable_port_stats();
  
  // @@protoc_insertion_point(class_scope:OstProto.PortStatsList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::OstProto::PortStats > port_stats_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();
  
  void InitAsDefaultInstance();
  static PortStatsList* default_instance_;
};
// ===================================================================

class OstService_Stub;

class OstService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline OstService() {};
 public:
  virtual ~OstService();
  
  typedef OstService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void getPortIdList(::google::protobuf::RpcController* controller,
                       const ::OstProto::Void* request,
                       ::OstProto::PortIdList* response,
                       ::google::protobuf::Closure* done);
  virtual void getPortConfig(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::PortConfigList* response,
                       ::google::protobuf::Closure* done);
  virtual void modifyPort(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortConfigList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  virtual void getStreamIdList(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortId* request,
                       ::OstProto::StreamIdList* response,
                       ::google::protobuf::Closure* done);
  virtual void getStreamConfig(::google::protobuf::RpcController* controller,
                       const ::OstProto::StreamIdList* request,
                       ::OstProto::StreamConfigList* response,
                       ::google::protobuf::Closure* done);
  virtual void addStream(::google::protobuf::RpcController* controller,
                       const ::OstProto::StreamIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  virtual void deleteStream(::google::protobuf::RpcController* controller,
                       const ::OstProto::StreamIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  virtual void modifyStream(::google::protobuf::RpcController* controller,
                       const ::OstProto::StreamConfigList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  virtual void startTransmit(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  virtual void stopTransmit(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  virtual void startCapture(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  virtual void stopCapture(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  virtual void getCaptureBuffer(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortId* request,
                       ::OstProto::CaptureBuffer* response,
                       ::google::protobuf::Closure* done);
  virtual void getStats(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::PortStatsList* response,
                       ::google::protobuf::Closure* done);
  virtual void clearStats(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  virtual void checkVersion(::google::protobuf::RpcController* controller,
                       const ::OstProto::VersionInfo* request,
                       ::OstProto::VersionCompatibility* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(OstService);
};

class OstService_Stub : public OstService {
 public:
  OstService_Stub(::google::protobuf::RpcChannel* channel);
  OstService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~OstService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements OstService ------------------------------------------
  
  void getPortIdList(::google::protobuf::RpcController* controller,
                       const ::OstProto::Void* request,
                       ::OstProto::PortIdList* response,
                       ::google::protobuf::Closure* done);
  void getPortConfig(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::PortConfigList* response,
                       ::google::protobuf::Closure* done);
  void modifyPort(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortConfigList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  void getStreamIdList(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortId* request,
                       ::OstProto::StreamIdList* response,
                       ::google::protobuf::Closure* done);
  void getStreamConfig(::google::protobuf::RpcController* controller,
                       const ::OstProto::StreamIdList* request,
                       ::OstProto::StreamConfigList* response,
                       ::google::protobuf::Closure* done);
  void addStream(::google::protobuf::RpcController* controller,
                       const ::OstProto::StreamIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  void deleteStream(::google::protobuf::RpcController* controller,
                       const ::OstProto::StreamIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  void modifyStream(::google::protobuf::RpcController* controller,
                       const ::OstProto::StreamConfigList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  void startTransmit(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  void stopTransmit(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  void startCapture(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  void stopCapture(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  void getCaptureBuffer(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortId* request,
                       ::OstProto::CaptureBuffer* response,
                       ::google::protobuf::Closure* done);
  void getStats(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::PortStatsList* response,
                       ::google::protobuf::Closure* done);
  void clearStats(::google::protobuf::RpcController* controller,
                       const ::OstProto::PortIdList* request,
                       ::OstProto::Ack* response,
                       ::google::protobuf::Closure* done);
  void checkVersion(::google::protobuf::RpcController* controller,
                       const ::OstProto::VersionInfo* request,
                       ::OstProto::VersionCompatibility* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(OstService_Stub);
};


// ===================================================================


// ===================================================================

// VersionInfo

// required string version = 1;
inline bool VersionInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionInfo::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VersionInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VersionInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& VersionInfo::version() const {
  return *version_;
}
inline void VersionInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void VersionInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void VersionInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VersionInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* VersionInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// VersionCompatibility

// required .OstProto.VersionCompatibility.Compatibility result = 1;
inline bool VersionCompatibility::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionCompatibility::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VersionCompatibility::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VersionCompatibility::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::OstProto::VersionCompatibility_Compatibility VersionCompatibility::result() const {
  return static_cast< ::OstProto::VersionCompatibility_Compatibility >(result_);
}
inline void VersionCompatibility::set_result(::OstProto::VersionCompatibility_Compatibility value) {
  GOOGLE_DCHECK(::OstProto::VersionCompatibility_Compatibility_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional string notes = 2;
inline bool VersionCompatibility::has_notes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VersionCompatibility::set_has_notes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VersionCompatibility::clear_has_notes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VersionCompatibility::clear_notes() {
  if (notes_ != &::google::protobuf::internal::kEmptyString) {
    notes_->clear();
  }
  clear_has_notes();
}
inline const ::std::string& VersionCompatibility::notes() const {
  return *notes_;
}
inline void VersionCompatibility::set_notes(const ::std::string& value) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(value);
}
inline void VersionCompatibility::set_notes(const char* value) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(value);
}
inline void VersionCompatibility::set_notes(const char* value, size_t size) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VersionCompatibility::mutable_notes() {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  return notes_;
}
inline ::std::string* VersionCompatibility::release_notes() {
  clear_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notes_;
    notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StreamId

// required uint32 id = 1;
inline bool StreamId::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamId::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamId::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamId::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 StreamId::id() const {
  return id_;
}
inline void StreamId::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// StreamCore

// optional string name = 1;
inline bool StreamCore::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamCore::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamCore::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamCore::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StreamCore::name() const {
  return *name_;
}
inline void StreamCore::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreamCore::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreamCore::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreamCore::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StreamCore::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool is_enabled = 2;
inline bool StreamCore::has_is_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamCore::set_has_is_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamCore::clear_has_is_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamCore::clear_is_enabled() {
  is_enabled_ = false;
  clear_has_is_enabled();
}
inline bool StreamCore::is_enabled() const {
  return is_enabled_;
}
inline void StreamCore::set_is_enabled(bool value) {
  set_has_is_enabled();
  is_enabled_ = value;
}

// optional uint32 ordinal = 3;
inline bool StreamCore::has_ordinal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StreamCore::set_has_ordinal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StreamCore::clear_has_ordinal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StreamCore::clear_ordinal() {
  ordinal_ = 0u;
  clear_has_ordinal();
}
inline ::google::protobuf::uint32 StreamCore::ordinal() const {
  return ordinal_;
}
inline void StreamCore::set_ordinal(::google::protobuf::uint32 value) {
  set_has_ordinal();
  ordinal_ = value;
}

// optional .OstProto.StreamCore.FrameLengthMode len_mode = 14 [default = e_fl_fixed];
inline bool StreamCore::has_len_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StreamCore::set_has_len_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StreamCore::clear_has_len_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StreamCore::clear_len_mode() {
  len_mode_ = 0;
  clear_has_len_mode();
}
inline ::OstProto::StreamCore_FrameLengthMode StreamCore::len_mode() const {
  return static_cast< ::OstProto::StreamCore_FrameLengthMode >(len_mode_);
}
inline void StreamCore::set_len_mode(::OstProto::StreamCore_FrameLengthMode value) {
  GOOGLE_DCHECK(::OstProto::StreamCore_FrameLengthMode_IsValid(value));
  set_has_len_mode();
  len_mode_ = value;
}

// optional uint32 frame_len = 15 [default = 64];
inline bool StreamCore::has_frame_len() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StreamCore::set_has_frame_len() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StreamCore::clear_has_frame_len() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StreamCore::clear_frame_len() {
  frame_len_ = 64u;
  clear_has_frame_len();
}
inline ::google::protobuf::uint32 StreamCore::frame_len() const {
  return frame_len_;
}
inline void StreamCore::set_frame_len(::google::protobuf::uint32 value) {
  set_has_frame_len();
  frame_len_ = value;
}

// optional uint32 frame_len_min = 16 [default = 64];
inline bool StreamCore::has_frame_len_min() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StreamCore::set_has_frame_len_min() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StreamCore::clear_has_frame_len_min() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StreamCore::clear_frame_len_min() {
  frame_len_min_ = 64u;
  clear_has_frame_len_min();
}
inline ::google::protobuf::uint32 StreamCore::frame_len_min() const {
  return frame_len_min_;
}
inline void StreamCore::set_frame_len_min(::google::protobuf::uint32 value) {
  set_has_frame_len_min();
  frame_len_min_ = value;
}

// optional uint32 frame_len_max = 17 [default = 1518];
inline bool StreamCore::has_frame_len_max() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StreamCore::set_has_frame_len_max() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StreamCore::clear_has_frame_len_max() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StreamCore::clear_frame_len_max() {
  frame_len_max_ = 1518u;
  clear_has_frame_len_max();
}
inline ::google::protobuf::uint32 StreamCore::frame_len_max() const {
  return frame_len_max_;
}
inline void StreamCore::set_frame_len_max(::google::protobuf::uint32 value) {
  set_has_frame_len_max();
  frame_len_max_ = value;
}

// -------------------------------------------------------------------

// StreamControl

// optional .OstProto.StreamControl.SendUnit unit = 1 [default = e_su_packets];
inline bool StreamControl::has_unit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamControl::set_has_unit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamControl::clear_has_unit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamControl::clear_unit() {
  unit_ = 0;
  clear_has_unit();
}
inline ::OstProto::StreamControl_SendUnit StreamControl::unit() const {
  return static_cast< ::OstProto::StreamControl_SendUnit >(unit_);
}
inline void StreamControl::set_unit(::OstProto::StreamControl_SendUnit value) {
  GOOGLE_DCHECK(::OstProto::StreamControl_SendUnit_IsValid(value));
  set_has_unit();
  unit_ = value;
}

// optional .OstProto.StreamControl.SendMode mode = 2 [default = e_sm_fixed];
inline bool StreamControl::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamControl::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamControl::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamControl::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::OstProto::StreamControl_SendMode StreamControl::mode() const {
  return static_cast< ::OstProto::StreamControl_SendMode >(mode_);
}
inline void StreamControl::set_mode(::OstProto::StreamControl_SendMode value) {
  GOOGLE_DCHECK(::OstProto::StreamControl_SendMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// optional uint32 num_packets = 3 [default = 1];
inline bool StreamControl::has_num_packets() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StreamControl::set_has_num_packets() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StreamControl::clear_has_num_packets() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StreamControl::clear_num_packets() {
  num_packets_ = 1u;
  clear_has_num_packets();
}
inline ::google::protobuf::uint32 StreamControl::num_packets() const {
  return num_packets_;
}
inline void StreamControl::set_num_packets(::google::protobuf::uint32 value) {
  set_has_num_packets();
  num_packets_ = value;
}

// optional uint32 num_bursts = 4 [default = 1];
inline bool StreamControl::has_num_bursts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StreamControl::set_has_num_bursts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StreamControl::clear_has_num_bursts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StreamControl::clear_num_bursts() {
  num_bursts_ = 1u;
  clear_has_num_bursts();
}
inline ::google::protobuf::uint32 StreamControl::num_bursts() const {
  return num_bursts_;
}
inline void StreamControl::set_num_bursts(::google::protobuf::uint32 value) {
  set_has_num_bursts();
  num_bursts_ = value;
}

// optional uint32 packets_per_burst = 5 [default = 10];
inline bool StreamControl::has_packets_per_burst() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StreamControl::set_has_packets_per_burst() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StreamControl::clear_has_packets_per_burst() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StreamControl::clear_packets_per_burst() {
  packets_per_burst_ = 10u;
  clear_has_packets_per_burst();
}
inline ::google::protobuf::uint32 StreamControl::packets_per_burst() const {
  return packets_per_burst_;
}
inline void StreamControl::set_packets_per_burst(::google::protobuf::uint32 value) {
  set_has_packets_per_burst();
  packets_per_burst_ = value;
}

// optional .OstProto.StreamControl.NextWhat next = 6 [default = e_nw_goto_next];
inline bool StreamControl::has_next() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StreamControl::set_has_next() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StreamControl::clear_has_next() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StreamControl::clear_next() {
  next_ = 1;
  clear_has_next();
}
inline ::OstProto::StreamControl_NextWhat StreamControl::next() const {
  return static_cast< ::OstProto::StreamControl_NextWhat >(next_);
}
inline void StreamControl::set_next(::OstProto::StreamControl_NextWhat value) {
  GOOGLE_DCHECK(::OstProto::StreamControl_NextWhat_IsValid(value));
  set_has_next();
  next_ = value;
}

// optional uint32 OBSOLETE_packets_per_sec = 7 [default = 1, deprecated = true];
inline bool StreamControl::has_obsolete_packets_per_sec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StreamControl::set_has_obsolete_packets_per_sec() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StreamControl::clear_has_obsolete_packets_per_sec() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StreamControl::clear_obsolete_packets_per_sec() {
  obsolete_packets_per_sec_ = 1u;
  clear_has_obsolete_packets_per_sec();
}
inline ::google::protobuf::uint32 StreamControl::obsolete_packets_per_sec() const {
  return obsolete_packets_per_sec_;
}
inline void StreamControl::set_obsolete_packets_per_sec(::google::protobuf::uint32 value) {
  set_has_obsolete_packets_per_sec();
  obsolete_packets_per_sec_ = value;
}

// optional uint32 OBSOLETE_bursts_per_sec = 8 [default = 1, deprecated = true];
inline bool StreamControl::has_obsolete_bursts_per_sec() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StreamControl::set_has_obsolete_bursts_per_sec() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StreamControl::clear_has_obsolete_bursts_per_sec() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StreamControl::clear_obsolete_bursts_per_sec() {
  obsolete_bursts_per_sec_ = 1u;
  clear_has_obsolete_bursts_per_sec();
}
inline ::google::protobuf::uint32 StreamControl::obsolete_bursts_per_sec() const {
  return obsolete_bursts_per_sec_;
}
inline void StreamControl::set_obsolete_bursts_per_sec(::google::protobuf::uint32 value) {
  set_has_obsolete_bursts_per_sec();
  obsolete_bursts_per_sec_ = value;
}

// optional double packets_per_sec = 9 [default = 1];
inline bool StreamControl::has_packets_per_sec() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StreamControl::set_has_packets_per_sec() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StreamControl::clear_has_packets_per_sec() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StreamControl::clear_packets_per_sec() {
  packets_per_sec_ = 1;
  clear_has_packets_per_sec();
}
inline double StreamControl::packets_per_sec() const {
  return packets_per_sec_;
}
inline void StreamControl::set_packets_per_sec(double value) {
  set_has_packets_per_sec();
  packets_per_sec_ = value;
}

// optional double bursts_per_sec = 10 [default = 1];
inline bool StreamControl::has_bursts_per_sec() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StreamControl::set_has_bursts_per_sec() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StreamControl::clear_has_bursts_per_sec() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StreamControl::clear_bursts_per_sec() {
  bursts_per_sec_ = 1;
  clear_has_bursts_per_sec();
}
inline double StreamControl::bursts_per_sec() const {
  return bursts_per_sec_;
}
inline void StreamControl::set_bursts_per_sec(double value) {
  set_has_bursts_per_sec();
  bursts_per_sec_ = value;
}

// -------------------------------------------------------------------

// ProtocolId

// required uint32 id = 1;
inline bool ProtocolId::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtocolId::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtocolId::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtocolId::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ProtocolId::id() const {
  return id_;
}
inline void ProtocolId::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// Protocol

// required .OstProto.ProtocolId protocol_id = 1;
inline bool Protocol::has_protocol_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Protocol::set_has_protocol_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Protocol::clear_has_protocol_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Protocol::clear_protocol_id() {
  if (protocol_id_ != NULL) protocol_id_->::OstProto::ProtocolId::Clear();
  clear_has_protocol_id();
}
inline const ::OstProto::ProtocolId& Protocol::protocol_id() const {
  return protocol_id_ != NULL ? *protocol_id_ : *default_instance_->protocol_id_;
}
inline ::OstProto::ProtocolId* Protocol::mutable_protocol_id() {
  set_has_protocol_id();
  if (protocol_id_ == NULL) protocol_id_ = new ::OstProto::ProtocolId;
  return protocol_id_;
}
inline ::OstProto::ProtocolId* Protocol::release_protocol_id() {
  clear_has_protocol_id();
  ::OstProto::ProtocolId* temp = protocol_id_;
  protocol_id_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Stream

// required .OstProto.StreamId stream_id = 1;
inline bool Stream::has_stream_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream::set_has_stream_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream::clear_has_stream_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream::clear_stream_id() {
  if (stream_id_ != NULL) stream_id_->::OstProto::StreamId::Clear();
  clear_has_stream_id();
}
inline const ::OstProto::StreamId& Stream::stream_id() const {
  return stream_id_ != NULL ? *stream_id_ : *default_instance_->stream_id_;
}
inline ::OstProto::StreamId* Stream::mutable_stream_id() {
  set_has_stream_id();
  if (stream_id_ == NULL) stream_id_ = new ::OstProto::StreamId;
  return stream_id_;
}
inline ::OstProto::StreamId* Stream::release_stream_id() {
  clear_has_stream_id();
  ::OstProto::StreamId* temp = stream_id_;
  stream_id_ = NULL;
  return temp;
}

// optional .OstProto.StreamCore core = 2;
inline bool Stream::has_core() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream::set_has_core() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream::clear_has_core() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream::clear_core() {
  if (core_ != NULL) core_->::OstProto::StreamCore::Clear();
  clear_has_core();
}
inline const ::OstProto::StreamCore& Stream::core() const {
  return core_ != NULL ? *core_ : *default_instance_->core_;
}
inline ::OstProto::StreamCore* Stream::mutable_core() {
  set_has_core();
  if (core_ == NULL) core_ = new ::OstProto::StreamCore;
  return core_;
}
inline ::OstProto::StreamCore* Stream::release_core() {
  clear_has_core();
  ::OstProto::StreamCore* temp = core_;
  core_ = NULL;
  return temp;
}

// optional .OstProto.StreamControl control = 3;
inline bool Stream::has_control() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Stream::set_has_control() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Stream::clear_has_control() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Stream::clear_control() {
  if (control_ != NULL) control_->::OstProto::StreamControl::Clear();
  clear_has_control();
}
inline const ::OstProto::StreamControl& Stream::control() const {
  return control_ != NULL ? *control_ : *default_instance_->control_;
}
inline ::OstProto::StreamControl* Stream::mutable_control() {
  set_has_control();
  if (control_ == NULL) control_ = new ::OstProto::StreamControl;
  return control_;
}
inline ::OstProto::StreamControl* Stream::release_control() {
  clear_has_control();
  ::OstProto::StreamControl* temp = control_;
  control_ = NULL;
  return temp;
}

// repeated .OstProto.Protocol protocol = 4;
inline int Stream::protocol_size() const {
  return protocol_.size();
}
inline void Stream::clear_protocol() {
  protocol_.Clear();
}
inline const ::OstProto::Protocol& Stream::protocol(int index) const {
  return protocol_.Get(index);
}
inline ::OstProto::Protocol* Stream::mutable_protocol(int index) {
  return protocol_.Mutable(index);
}
inline ::OstProto::Protocol* Stream::add_protocol() {
  return protocol_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OstProto::Protocol >&
Stream::protocol() const {
  return protocol_;
}
inline ::google::protobuf::RepeatedPtrField< ::OstProto::Protocol >*
Stream::mutable_protocol() {
  return &protocol_;
}

// -------------------------------------------------------------------

// Void

// -------------------------------------------------------------------

// Ack

// -------------------------------------------------------------------

// PortId

// required uint32 id = 1;
inline bool PortId::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortId::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortId::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortId::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 PortId::id() const {
  return id_;
}
inline void PortId::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// PortIdList

// repeated .OstProto.PortId port_id = 1;
inline int PortIdList::port_id_size() const {
  return port_id_.size();
}
inline void PortIdList::clear_port_id() {
  port_id_.Clear();
}
inline const ::OstProto::PortId& PortIdList::port_id(int index) const {
  return port_id_.Get(index);
}
inline ::OstProto::PortId* PortIdList::mutable_port_id(int index) {
  return port_id_.Mutable(index);
}
inline ::OstProto::PortId* PortIdList::add_port_id() {
  return port_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OstProto::PortId >&
PortIdList::port_id() const {
  return port_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::OstProto::PortId >*
PortIdList::mutable_port_id() {
  return &port_id_;
}

// -------------------------------------------------------------------

// StreamIdList

// required .OstProto.PortId port_id = 1;
inline bool StreamIdList::has_port_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamIdList::set_has_port_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamIdList::clear_has_port_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamIdList::clear_port_id() {
  if (port_id_ != NULL) port_id_->::OstProto::PortId::Clear();
  clear_has_port_id();
}
inline const ::OstProto::PortId& StreamIdList::port_id() const {
  return port_id_ != NULL ? *port_id_ : *default_instance_->port_id_;
}
inline ::OstProto::PortId* StreamIdList::mutable_port_id() {
  set_has_port_id();
  if (port_id_ == NULL) port_id_ = new ::OstProto::PortId;
  return port_id_;
}
inline ::OstProto::PortId* StreamIdList::release_port_id() {
  clear_has_port_id();
  ::OstProto::PortId* temp = port_id_;
  port_id_ = NULL;
  return temp;
}

// repeated .OstProto.StreamId stream_id = 2;
inline int StreamIdList::stream_id_size() const {
  return stream_id_.size();
}
inline void StreamIdList::clear_stream_id() {
  stream_id_.Clear();
}
inline const ::OstProto::StreamId& StreamIdList::stream_id(int index) const {
  return stream_id_.Get(index);
}
inline ::OstProto::StreamId* StreamIdList::mutable_stream_id(int index) {
  return stream_id_.Mutable(index);
}
inline ::OstProto::StreamId* StreamIdList::add_stream_id() {
  return stream_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OstProto::StreamId >&
StreamIdList::stream_id() const {
  return stream_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::OstProto::StreamId >*
StreamIdList::mutable_stream_id() {
  return &stream_id_;
}

// -------------------------------------------------------------------

// Port

// required .OstProto.PortId port_id = 1;
inline bool Port::has_port_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Port::set_has_port_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Port::clear_has_port_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Port::clear_port_id() {
  if (port_id_ != NULL) port_id_->::OstProto::PortId::Clear();
  clear_has_port_id();
}
inline const ::OstProto::PortId& Port::port_id() const {
  return port_id_ != NULL ? *port_id_ : *default_instance_->port_id_;
}
inline ::OstProto::PortId* Port::mutable_port_id() {
  set_has_port_id();
  if (port_id_ == NULL) port_id_ = new ::OstProto::PortId;
  return port_id_;
}
inline ::OstProto::PortId* Port::release_port_id() {
  clear_has_port_id();
  ::OstProto::PortId* temp = port_id_;
  port_id_ = NULL;
  return temp;
}

// optional string name = 2;
inline bool Port::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Port::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Port::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Port::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Port::name() const {
  return *name_;
}
inline void Port::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Port::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Port::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Port::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Port::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string description = 3;
inline bool Port::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Port::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Port::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Port::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Port::description() const {
  return *description_;
}
inline void Port::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Port::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Port::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Port::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* Port::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string notes = 4;
inline bool Port::has_notes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Port::set_has_notes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Port::clear_has_notes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Port::clear_notes() {
  if (notes_ != &::google::protobuf::internal::kEmptyString) {
    notes_->clear();
  }
  clear_has_notes();
}
inline const ::std::string& Port::notes() const {
  return *notes_;
}
inline void Port::set_notes(const ::std::string& value) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(value);
}
inline void Port::set_notes(const char* value) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(value);
}
inline void Port::set_notes(const char* value, size_t size) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Port::mutable_notes() {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  return notes_;
}
inline ::std::string* Port::release_notes() {
  clear_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notes_;
    notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool is_enabled = 5;
inline bool Port::has_is_enabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Port::set_has_is_enabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Port::clear_has_is_enabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Port::clear_is_enabled() {
  is_enabled_ = false;
  clear_has_is_enabled();
}
inline bool Port::is_enabled() const {
  return is_enabled_;
}
inline void Port::set_is_enabled(bool value) {
  set_has_is_enabled();
  is_enabled_ = value;
}

// optional bool is_exclusive_control = 6;
inline bool Port::has_is_exclusive_control() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Port::set_has_is_exclusive_control() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Port::clear_has_is_exclusive_control() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Port::clear_is_exclusive_control() {
  is_exclusive_control_ = false;
  clear_has_is_exclusive_control();
}
inline bool Port::is_exclusive_control() const {
  return is_exclusive_control_;
}
inline void Port::set_is_exclusive_control(bool value) {
  set_has_is_exclusive_control();
  is_exclusive_control_ = value;
}

// optional .OstProto.TransmitMode transmit_mode = 7 [default = kSequentialTransmit];
inline bool Port::has_transmit_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Port::set_has_transmit_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Port::clear_has_transmit_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Port::clear_transmit_mode() {
  transmit_mode_ = 0;
  clear_has_transmit_mode();
}
inline OstProto::TransmitMode Port::transmit_mode() const {
  return static_cast< OstProto::TransmitMode >(transmit_mode_);
}
inline void Port::set_transmit_mode(OstProto::TransmitMode value) {
  GOOGLE_DCHECK(OstProto::TransmitMode_IsValid(value));
  set_has_transmit_mode();
  transmit_mode_ = value;
}

// -------------------------------------------------------------------

// PortConfigList

// repeated .OstProto.Port port = 1;
inline int PortConfigList::port_size() const {
  return port_.size();
}
inline void PortConfigList::clear_port() {
  port_.Clear();
}
inline const ::OstProto::Port& PortConfigList::port(int index) const {
  return port_.Get(index);
}
inline ::OstProto::Port* PortConfigList::mutable_port(int index) {
  return port_.Mutable(index);
}
inline ::OstProto::Port* PortConfigList::add_port() {
  return port_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OstProto::Port >&
PortConfigList::port() const {
  return port_;
}
inline ::google::protobuf::RepeatedPtrField< ::OstProto::Port >*
PortConfigList::mutable_port() {
  return &port_;
}

// -------------------------------------------------------------------

// StreamConfigList

// required .OstProto.PortId port_id = 1;
inline bool StreamConfigList::has_port_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamConfigList::set_has_port_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamConfigList::clear_has_port_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamConfigList::clear_port_id() {
  if (port_id_ != NULL) port_id_->::OstProto::PortId::Clear();
  clear_has_port_id();
}
inline const ::OstProto::PortId& StreamConfigList::port_id() const {
  return port_id_ != NULL ? *port_id_ : *default_instance_->port_id_;
}
inline ::OstProto::PortId* StreamConfigList::mutable_port_id() {
  set_has_port_id();
  if (port_id_ == NULL) port_id_ = new ::OstProto::PortId;
  return port_id_;
}
inline ::OstProto::PortId* StreamConfigList::release_port_id() {
  clear_has_port_id();
  ::OstProto::PortId* temp = port_id_;
  port_id_ = NULL;
  return temp;
}

// repeated .OstProto.Stream stream = 2;
inline int StreamConfigList::stream_size() const {
  return stream_.size();
}
inline void StreamConfigList::clear_stream() {
  stream_.Clear();
}
inline const ::OstProto::Stream& StreamConfigList::stream(int index) const {
  return stream_.Get(index);
}
inline ::OstProto::Stream* StreamConfigList::mutable_stream(int index) {
  return stream_.Mutable(index);
}
inline ::OstProto::Stream* StreamConfigList::add_stream() {
  return stream_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OstProto::Stream >&
StreamConfigList::stream() const {
  return stream_;
}
inline ::google::protobuf::RepeatedPtrField< ::OstProto::Stream >*
StreamConfigList::mutable_stream() {
  return &stream_;
}

// -------------------------------------------------------------------

// CaptureBuffer

// -------------------------------------------------------------------

// CaptureBufferList

// repeated .OstProto.CaptureBuffer list = 1;
inline int CaptureBufferList::list_size() const {
  return list_.size();
}
inline void CaptureBufferList::clear_list() {
  list_.Clear();
}
inline const ::OstProto::CaptureBuffer& CaptureBufferList::list(int index) const {
  return list_.Get(index);
}
inline ::OstProto::CaptureBuffer* CaptureBufferList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::OstProto::CaptureBuffer* CaptureBufferList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OstProto::CaptureBuffer >&
CaptureBufferList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::OstProto::CaptureBuffer >*
CaptureBufferList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// PortState

// optional .OstProto.LinkState link_state = 1 [default = LinkStateUnknown];
inline bool PortState::has_link_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortState::set_has_link_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortState::clear_has_link_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortState::clear_link_state() {
  link_state_ = 0;
  clear_has_link_state();
}
inline OstProto::LinkState PortState::link_state() const {
  return static_cast< OstProto::LinkState >(link_state_);
}
inline void PortState::set_link_state(OstProto::LinkState value) {
  GOOGLE_DCHECK(OstProto::LinkState_IsValid(value));
  set_has_link_state();
  link_state_ = value;
}

// optional bool is_transmit_on = 2 [default = false];
inline bool PortState::has_is_transmit_on() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PortState::set_has_is_transmit_on() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PortState::clear_has_is_transmit_on() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PortState::clear_is_transmit_on() {
  is_transmit_on_ = false;
  clear_has_is_transmit_on();
}
inline bool PortState::is_transmit_on() const {
  return is_transmit_on_;
}
inline void PortState::set_is_transmit_on(bool value) {
  set_has_is_transmit_on();
  is_transmit_on_ = value;
}

// optional bool is_capture_on = 3 [default = false];
inline bool PortState::has_is_capture_on() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PortState::set_has_is_capture_on() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PortState::clear_has_is_capture_on() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PortState::clear_is_capture_on() {
  is_capture_on_ = false;
  clear_has_is_capture_on();
}
inline bool PortState::is_capture_on() const {
  return is_capture_on_;
}
inline void PortState::set_is_capture_on(bool value) {
  set_has_is_capture_on();
  is_capture_on_ = value;
}

// -------------------------------------------------------------------

// PortStats

// required .OstProto.PortId port_id = 1;
inline bool PortStats::has_port_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortStats::set_has_port_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortStats::clear_has_port_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortStats::clear_port_id() {
  if (port_id_ != NULL) port_id_->::OstProto::PortId::Clear();
  clear_has_port_id();
}
inline const ::OstProto::PortId& PortStats::port_id() const {
  return port_id_ != NULL ? *port_id_ : *default_instance_->port_id_;
}
inline ::OstProto::PortId* PortStats::mutable_port_id() {
  set_has_port_id();
  if (port_id_ == NULL) port_id_ = new ::OstProto::PortId;
  return port_id_;
}
inline ::OstProto::PortId* PortStats::release_port_id() {
  clear_has_port_id();
  ::OstProto::PortId* temp = port_id_;
  port_id_ = NULL;
  return temp;
}

// optional .OstProto.PortState state = 2;
inline bool PortStats::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PortStats::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PortStats::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PortStats::clear_state() {
  if (state_ != NULL) state_->::OstProto::PortState::Clear();
  clear_has_state();
}
inline const ::OstProto::PortState& PortStats::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::OstProto::PortState* PortStats::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::OstProto::PortState;
  return state_;
}
inline ::OstProto::PortState* PortStats::release_state() {
  clear_has_state();
  ::OstProto::PortState* temp = state_;
  state_ = NULL;
  return temp;
}

// optional uint64 rx_pkts = 11;
inline bool PortStats::has_rx_pkts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PortStats::set_has_rx_pkts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PortStats::clear_has_rx_pkts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PortStats::clear_rx_pkts() {
  rx_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_pkts();
}
inline ::google::protobuf::uint64 PortStats::rx_pkts() const {
  return rx_pkts_;
}
inline void PortStats::set_rx_pkts(::google::protobuf::uint64 value) {
  set_has_rx_pkts();
  rx_pkts_ = value;
}

// optional uint64 rx_bytes = 12;
inline bool PortStats::has_rx_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PortStats::set_has_rx_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PortStats::clear_has_rx_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PortStats::clear_rx_bytes() {
  rx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_bytes();
}
inline ::google::protobuf::uint64 PortStats::rx_bytes() const {
  return rx_bytes_;
}
inline void PortStats::set_rx_bytes(::google::protobuf::uint64 value) {
  set_has_rx_bytes();
  rx_bytes_ = value;
}

// optional uint64 rx_pkts_nic = 13;
inline bool PortStats::has_rx_pkts_nic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PortStats::set_has_rx_pkts_nic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PortStats::clear_has_rx_pkts_nic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PortStats::clear_rx_pkts_nic() {
  rx_pkts_nic_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_pkts_nic();
}
inline ::google::protobuf::uint64 PortStats::rx_pkts_nic() const {
  return rx_pkts_nic_;
}
inline void PortStats::set_rx_pkts_nic(::google::protobuf::uint64 value) {
  set_has_rx_pkts_nic();
  rx_pkts_nic_ = value;
}

// optional uint64 rx_bytes_nic = 14;
inline bool PortStats::has_rx_bytes_nic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PortStats::set_has_rx_bytes_nic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PortStats::clear_has_rx_bytes_nic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PortStats::clear_rx_bytes_nic() {
  rx_bytes_nic_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_bytes_nic();
}
inline ::google::protobuf::uint64 PortStats::rx_bytes_nic() const {
  return rx_bytes_nic_;
}
inline void PortStats::set_rx_bytes_nic(::google::protobuf::uint64 value) {
  set_has_rx_bytes_nic();
  rx_bytes_nic_ = value;
}

// optional uint64 rx_pps = 15;
inline bool PortStats::has_rx_pps() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PortStats::set_has_rx_pps() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PortStats::clear_has_rx_pps() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PortStats::clear_rx_pps() {
  rx_pps_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_pps();
}
inline ::google::protobuf::uint64 PortStats::rx_pps() const {
  return rx_pps_;
}
inline void PortStats::set_rx_pps(::google::protobuf::uint64 value) {
  set_has_rx_pps();
  rx_pps_ = value;
}

// optional uint64 rx_bps = 16;
inline bool PortStats::has_rx_bps() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PortStats::set_has_rx_bps() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PortStats::clear_has_rx_bps() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PortStats::clear_rx_bps() {
  rx_bps_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_bps();
}
inline ::google::protobuf::uint64 PortStats::rx_bps() const {
  return rx_bps_;
}
inline void PortStats::set_rx_bps(::google::protobuf::uint64 value) {
  set_has_rx_bps();
  rx_bps_ = value;
}

// optional uint64 tx_pkts = 21;
inline bool PortStats::has_tx_pkts() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PortStats::set_has_tx_pkts() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PortStats::clear_has_tx_pkts() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PortStats::clear_tx_pkts() {
  tx_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_pkts();
}
inline ::google::protobuf::uint64 PortStats::tx_pkts() const {
  return tx_pkts_;
}
inline void PortStats::set_tx_pkts(::google::protobuf::uint64 value) {
  set_has_tx_pkts();
  tx_pkts_ = value;
}

// optional uint64 tx_bytes = 22;
inline bool PortStats::has_tx_bytes() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PortStats::set_has_tx_bytes() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PortStats::clear_has_tx_bytes() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PortStats::clear_tx_bytes() {
  tx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_bytes();
}
inline ::google::protobuf::uint64 PortStats::tx_bytes() const {
  return tx_bytes_;
}
inline void PortStats::set_tx_bytes(::google::protobuf::uint64 value) {
  set_has_tx_bytes();
  tx_bytes_ = value;
}

// optional uint64 tx_pkts_nic = 23;
inline bool PortStats::has_tx_pkts_nic() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PortStats::set_has_tx_pkts_nic() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PortStats::clear_has_tx_pkts_nic() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PortStats::clear_tx_pkts_nic() {
  tx_pkts_nic_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_pkts_nic();
}
inline ::google::protobuf::uint64 PortStats::tx_pkts_nic() const {
  return tx_pkts_nic_;
}
inline void PortStats::set_tx_pkts_nic(::google::protobuf::uint64 value) {
  set_has_tx_pkts_nic();
  tx_pkts_nic_ = value;
}

// optional uint64 tx_bytes_nic = 24;
inline bool PortStats::has_tx_bytes_nic() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PortStats::set_has_tx_bytes_nic() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PortStats::clear_has_tx_bytes_nic() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PortStats::clear_tx_bytes_nic() {
  tx_bytes_nic_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_bytes_nic();
}
inline ::google::protobuf::uint64 PortStats::tx_bytes_nic() const {
  return tx_bytes_nic_;
}
inline void PortStats::set_tx_bytes_nic(::google::protobuf::uint64 value) {
  set_has_tx_bytes_nic();
  tx_bytes_nic_ = value;
}

// optional uint64 tx_pps = 25;
inline bool PortStats::has_tx_pps() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PortStats::set_has_tx_pps() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PortStats::clear_has_tx_pps() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PortStats::clear_tx_pps() {
  tx_pps_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_pps();
}
inline ::google::protobuf::uint64 PortStats::tx_pps() const {
  return tx_pps_;
}
inline void PortStats::set_tx_pps(::google::protobuf::uint64 value) {
  set_has_tx_pps();
  tx_pps_ = value;
}

// optional uint64 tx_bps = 26;
inline bool PortStats::has_tx_bps() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PortStats::set_has_tx_bps() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PortStats::clear_has_tx_bps() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PortStats::clear_tx_bps() {
  tx_bps_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_bps();
}
inline ::google::protobuf::uint64 PortStats::tx_bps() const {
  return tx_bps_;
}
inline void PortStats::set_tx_bps(::google::protobuf::uint64 value) {
  set_has_tx_bps();
  tx_bps_ = value;
}

// optional uint64 rx_drops = 100;
inline bool PortStats::has_rx_drops() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PortStats::set_has_rx_drops() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PortStats::clear_has_rx_drops() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PortStats::clear_rx_drops() {
  rx_drops_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_drops();
}
inline ::google::protobuf::uint64 PortStats::rx_drops() const {
  return rx_drops_;
}
inline void PortStats::set_rx_drops(::google::protobuf::uint64 value) {
  set_has_rx_drops();
  rx_drops_ = value;
}

// optional uint64 rx_errors = 101;
inline bool PortStats::has_rx_errors() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PortStats::set_has_rx_errors() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PortStats::clear_has_rx_errors() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PortStats::clear_rx_errors() {
  rx_errors_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_errors();
}
inline ::google::protobuf::uint64 PortStats::rx_errors() const {
  return rx_errors_;
}
inline void PortStats::set_rx_errors(::google::protobuf::uint64 value) {
  set_has_rx_errors();
  rx_errors_ = value;
}

// optional uint64 rx_fifo_errors = 102;
inline bool PortStats::has_rx_fifo_errors() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PortStats::set_has_rx_fifo_errors() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PortStats::clear_has_rx_fifo_errors() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PortStats::clear_rx_fifo_errors() {
  rx_fifo_errors_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_fifo_errors();
}
inline ::google::protobuf::uint64 PortStats::rx_fifo_errors() const {
  return rx_fifo_errors_;
}
inline void PortStats::set_rx_fifo_errors(::google::protobuf::uint64 value) {
  set_has_rx_fifo_errors();
  rx_fifo_errors_ = value;
}

// optional uint64 rx_frame_errors = 103;
inline bool PortStats::has_rx_frame_errors() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PortStats::set_has_rx_frame_errors() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PortStats::clear_has_rx_frame_errors() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PortStats::clear_rx_frame_errors() {
  rx_frame_errors_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_frame_errors();
}
inline ::google::protobuf::uint64 PortStats::rx_frame_errors() const {
  return rx_frame_errors_;
}
inline void PortStats::set_rx_frame_errors(::google::protobuf::uint64 value) {
  set_has_rx_frame_errors();
  rx_frame_errors_ = value;
}

// -------------------------------------------------------------------

// PortStatsList

// repeated .OstProto.PortStats port_stats = 1;
inline int PortStatsList::port_stats_size() const {
  return port_stats_.size();
}
inline void PortStatsList::clear_port_stats() {
  port_stats_.Clear();
}
inline const ::OstProto::PortStats& PortStatsList::port_stats(int index) const {
  return port_stats_.Get(index);
}
inline ::OstProto::PortStats* PortStatsList::mutable_port_stats(int index) {
  return port_stats_.Mutable(index);
}
inline ::OstProto::PortStats* PortStatsList::add_port_stats() {
  return port_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OstProto::PortStats >&
PortStatsList::port_stats() const {
  return port_stats_;
}
inline ::google::protobuf::RepeatedPtrField< ::OstProto::PortStats >*
PortStatsList::mutable_port_stats() {
  return &port_stats_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace OstProto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OstProto::VersionCompatibility_Compatibility>() {
  return ::OstProto::VersionCompatibility_Compatibility_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OstProto::StreamCore_FrameLengthMode>() {
  return ::OstProto::StreamCore_FrameLengthMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OstProto::StreamControl_SendUnit>() {
  return ::OstProto::StreamControl_SendUnit_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OstProto::StreamControl_SendMode>() {
  return ::OstProto::StreamControl_SendMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OstProto::StreamControl_NextWhat>() {
  return ::OstProto::StreamControl_NextWhat_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OstProto::Protocol_k>() {
  return ::OstProto::Protocol_k_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< OstProto::TransmitMode>() {
  return OstProto::TransmitMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< OstProto::LinkState>() {
  return OstProto::LinkState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocol_2eproto__INCLUDED
